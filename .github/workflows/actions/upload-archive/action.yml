name: Upload Compressed Artifacts
description: Compresses and uploads artifacts with caching for faster workflow access

inputs:
  paths:
    description: 'Path(s) to upload'
    required: true
  output:
    description: 'Output directory for the compressed file'
    required: false
    default: 'dist'
  name:
    description: 'Name of the artifact'
    required: true
  cache_key_prefix:
    description: 'Prefix for cache key'
    required: false
    default: 'artifacts'
  retention_days:
    description: 'Number of days to keep artifacts'
    required: false
    default: '1'
  custom_cache_key:
    description: 'Custom cache key to use instead of auto-generated'
    required: false
  use_cache:
    description: 'Whether to use cache'
    required: false
    default: 'true'

outputs:
  filename:
    description: 'Filename of the created archive'
    value: ${{ steps.create-archive.outputs.filename }}
  size:
    description: 'Size of the created archive in bytes'
    value: ${{ steps.create-archive.outputs.size }}
  cache_key:
    description: 'Key used for the cache'
    value: ${{ steps.generate-keys.outputs.cache_key }}

runs:
  using: composite
  steps:
    # Generate standard cache keys
    - name: 🔑 Generate Cache Keys
      id: generate-keys
      shell: bash
      run: |
        # Ensure cache key prefix has a value
        CACHE_PREFIX="${{ inputs.cache_key_prefix || 'artifacts' }}"
        NAME="${{ inputs.name }}"
        OS="${{ runner.os }}"
        RUN_ID="${{ github.run_id }}"

        # If a custom key is provided, use that
        if [ -n "${{ inputs.custom_cache_key }}" ]; then
          echo "standard_key=${{ inputs.custom_cache_key }}" >> $GITHUB_OUTPUT
          echo "::notice::Using custom cache key: ${{ inputs.custom_cache_key }}"
        else
          # Generate a standard cache key - format matches download-archive
          STANDARD_KEY="${OS}-${CACHE_PREFIX}-${NAME}-${RUN_ID}"
          echo "standard_key=${STANDARD_KEY}" >> $GITHUB_OUTPUT
          echo "::notice::Generated standard cache key: ${STANDARD_KEY}"

          # Generate OS-agnostic key for cross-platform compatibility
          AGNOSTIC_KEY="${CACHE_PREFIX}-${NAME}-${RUN_ID}"
          echo "agnostic_key=${AGNOSTIC_KEY}" >> $GITHUB_OUTPUT
          echo "::notice::Generated OS-agnostic key: ${AGNOSTIC_KEY}"
        fi

    # Create the archive
    - name: 📦 Create Archive
      id: create-archive
      shell: bash
      run: |
        # Create output directory if it doesn't exist
        mkdir -p "${{ inputs.output }}"

        # Create the zip file without using the artifact name in the path
        FILENAME="artifact.zip"
        echo "::notice::Compressing ${{ inputs.paths }} to ${{ inputs.output }}/${FILENAME}"

        # Debug paths before creating archive
        echo "::notice::===== DEBUG PATHS TO ARCHIVE ====="
        for path in ${{ inputs.paths }}; do
          echo "::notice::Path pattern: $path"
          echo "::notice::Matching files (sample):"
          find "${{ github.workspace }}" -path "*$path*" 2>/dev/null | sort | head -n 20 || echo "Error listing files"

          # Count total files matching the pattern
          TOTAL_FILES=$(find "${{ github.workspace }}" -path "*$path*" 2>/dev/null | wc -l || echo "unknown")
          echo "::notice::Total files matching this pattern: ${TOTAL_FILES}"
        done

        # Use zip to create the archive
        cd "${{ github.workspace }}" && zip -r "${{ inputs.output }}/${FILENAME}" ${{ inputs.paths }}

        # Check if the file was created
        if [ -f "${{ inputs.output }}/${FILENAME}" ]; then
          FILE_SIZE=$(stat -c%s "${{ inputs.output }}/${FILENAME}" 2>/dev/null || stat -f%z "${{ inputs.output }}/${FILENAME}" 2>/dev/null || ls -l "${{ inputs.output }}/${FILENAME}" | awk '{print $5}')
          echo "::notice::Created archive: ${{ inputs.output }}/${FILENAME} ($(du -h "${{ inputs.output }}/${FILENAME}" | cut -f1))"
          echo "filename=${FILENAME}" >> $GITHUB_OUTPUT
          echo "size=${FILE_SIZE}" >> $GITHUB_OUTPUT

          # List archive contents
          echo "::notice::Archive contents:"
          unzip -l "${{ inputs.output }}/${FILENAME}" | head -n 20
        else
          echo "::error::Failed to create archive"
          exit 1
        fi

    # Save the archive to cache with OS-specific key
    - name: 🗄️ Cache Archive (OS-specific)
      id: cache-save
      if: inputs.use_cache != 'false'
      uses: actions/cache/save@v4
      env:
        ACTIONS_CACHE_SERVICE_V2: 'true'
      with:
        path: ${{ inputs.output }}/${{ steps.create-archive.outputs.filename }}
        key: ${{ steps.generate-keys.outputs.standard_key }}
        enableCrossOsArchive: true

    # Save with OS-agnostic key for better cross-OS compatibility
    - name: 🗄️ Cache Archive (OS-agnostic)
      id: cache-save-agnostic
      if: inputs.use_cache != 'false'
      uses: actions/cache/save@v4
      env:
        ACTIONS_CACHE_SERVICE_V2: 'true'
      with:
        path: ${{ inputs.output }}/${{ steps.create-archive.outputs.filename }}
        key: ${{ steps.generate-keys.outputs.agnostic_key }}
        enableCrossOsArchive: true

    # Log cache details for debugging
    - name: 📊 Cache Operation Details
      shell: bash
      run: |
        echo "::notice::===== CACHE SAVE DETAILS ====="
        echo "::notice::Cache keys used:"
        echo "::notice:: - OS-specific: ${{ steps.generate-keys.outputs.standard_key }}"
        echo "::notice:: - OS-agnostic: ${{ steps.generate-keys.outputs.agnostic_key }}"
        echo "::notice::File details:"
        echo "::notice:: - Path for caching: ${{ inputs.output }}/${{ steps.create-archive.outputs.filename }}"

        # Check file exists and get size info
        if [ -f "${{ inputs.output }}/${{ steps.create-archive.outputs.filename }}" ]; then
          SIZE=$(stat -c%s "${{ inputs.output }}/${{ steps.create-archive.outputs.filename }}" 2>/dev/null || stat -f%z "${{ inputs.output }}/${{ steps.create-archive.outputs.filename }}" 2>/dev/null || ls -l "${{ inputs.output }}/${{ steps.create-archive.outputs.filename }}" | awk '{print $5}')
          echo "::notice:: - Size: $(du -h "${{ inputs.output }}/${{ steps.create-archive.outputs.filename }}" | cut -f1) (${SIZE} bytes)"
          echo "::notice:: - Exists: YES"
        else
          echo "::warning:: - File does not exist!"
        fi

    # Save to standard artifact storage as fallback
    - name: 📤 Upload Artifact
      if: inputs.use_cache != 'true-only'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.name }}
        path: ${{ inputs.output }}/${{ steps.create-archive.outputs.filename }}
        retention-days: ${{ inputs.retention_days }}
