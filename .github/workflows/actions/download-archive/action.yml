name: 'Download and Extract Artifacts'
description: 'Downloads and extracts compressed artifacts shared from previous jobs using GitHub cache (90-day retention)'
inputs:
  path:
    description: 'Destination directory to extract the artifact contents'
    required: true
  filename:
    description: 'Filename of the compressed artifact to download'
    required: true
    default: 'artifact.zip'
  name:
    description: 'Artifact name as used in the cache key'
    required: true
  cache_key_prefix:
    description: 'Prefix for the cache key (must match upload setting)'
    default: 'build-artifacts'
    required: false
  exact_cache_key:
    description: 'Exact cache key to use for retrieval (if provided)'
    required: false
  use_cache:
    description: 'Use cache only (true-only or false-only)'
    required: false
runs:
  using: 'composite'
  steps:
    # Generate standard cache keys
    - name: üîë Generate Cache Keys
      id: generate-keys
      shell: bash
      run: |
        # Ensure values have defaults
        CACHE_PREFIX="${{ inputs.cache_key_prefix || 'artifacts' }}"
        NAME="${{ inputs.name }}"
        OS="${{ runner.os }}"
        RUN_ID="${{ github.run_id }}"

        # Generate standard key (os-specific)
        STANDARD_KEY="${OS}-${CACHE_PREFIX}-${NAME}-${RUN_ID}"
        echo "standard_key=${STANDARD_KEY}" >> $GITHUB_OUTPUT
        echo "::notice::Standard key: ${STANDARD_KEY}"

        # Generate OS-agnostic key
        AGNOSTIC_KEY="${CACHE_PREFIX}-${NAME}-${RUN_ID}"
        echo "agnostic_key=${AGNOSTIC_KEY}" >> $GITHUB_OUTPUT
        echo "::notice::OS-agnostic key: ${AGNOSTIC_KEY}"

        # Generate Linux-specific key for cross-OS compatibility
        LINUX_KEY="Linux-${CACHE_PREFIX}-${NAME}-${RUN_ID}"
        echo "linux_key=${LINUX_KEY}" >> $GITHUB_OUTPUT
        echo "::notice::Linux key: ${LINUX_KEY}"

        # Generate pattern keys
        PATTERN_KEY="${OS}-${CACHE_PREFIX}-${NAME}-"
        echo "pattern_key=${PATTERN_KEY}" >> $GITHUB_OUTPUT
        echo "::notice::Pattern key: ${PATTERN_KEY}"

        # Generate OS-agnostic pattern
        AGNOSTIC_PATTERN="${CACHE_PREFIX}-${NAME}-"
        echo "agnostic_pattern=${AGNOSTIC_PATTERN}" >> $GITHUB_OUTPUT
        echo "::notice::OS-agnostic pattern: ${AGNOSTIC_PATTERN}"

        # Generate RunID pattern for last resort lookup
        RUN_ID_PATTERN="*${RUN_ID}*"
        echo "run_id_pattern=${RUN_ID_PATTERN}" >> $GITHUB_OUTPUT
        echo "::notice::Run ID pattern: ${RUN_ID_PATTERN}"

    # List available caches for debugging
    - name: üìã List Available Caches
      id: list-caches
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        ACTIONS_CACHE_SERVICE_V2: 'true'
      run: |
        echo "::notice::===== AVAILABLE CACHES ====="
        gh cache list --limit 20 || echo "::warning::Unable to list caches with GH CLI"

    # Restore cache with exact key (if provided)
    - name: üóÑÔ∏è Restore with Exact Key
      id: cache-restore-exact
      if: inputs.exact_cache_key != ''
      uses: actions/cache/restore@v4
      env:
        ACTIONS_CACHE_SERVICE_V2: 'true'
      with:
        path: ${{ inputs.path }}/${{ inputs.filename }}
        key: ${{ inputs.exact_cache_key }}
        enableCrossOsArchive: true
        lookup-only: false
        fail-on-cache-miss: false

    # Restore with standard key (os-specific)
    - name: üóÑÔ∏è Restore with Standard Key
      id: cache-restore-standard
      if: steps.cache-restore-exact.outputs.cache-hit != 'true'
      uses: actions/cache/restore@v4
      env:
        ACTIONS_CACHE_SERVICE_V2: 'true'
      with:
        path: ${{ inputs.path }}/${{ inputs.filename }}
        key: ${{ steps.generate-keys.outputs.standard_key }}
        enableCrossOsArchive: true
        lookup-only: false
        fail-on-cache-miss: false

    # Restore with OS-agnostic key
    - name: üóÑÔ∏è Restore with OS-Agnostic Key
      id: cache-restore-agnostic
      if: steps.cache-restore-exact.outputs.cache-hit != 'true' && steps.cache-restore-standard.outputs.cache-hit != 'true'
      uses: actions/cache/restore@v4
      env:
        ACTIONS_CACHE_SERVICE_V2: 'true'
      with:
        path: ${{ inputs.path }}/${{ inputs.filename }}
        key: ${{ steps.generate-keys.outputs.agnostic_key }}
        enableCrossOsArchive: true
        lookup-only: false
        fail-on-cache-miss: false

    # Restore with Linux key for cross-OS compatibility
    - name: üóÑÔ∏è Restore with Linux Key
      id: cache-restore-linux
      if: steps.cache-restore-exact.outputs.cache-hit != 'true' && steps.cache-restore-standard.outputs.cache-hit != 'true' && steps.cache-restore-agnostic.outputs.cache-hit != 'true' && runner.os != 'Linux'
      uses: actions/cache/restore@v4
      env:
        ACTIONS_CACHE_SERVICE_V2: 'true'
      with:
        path: ${{ inputs.path }}/${{ inputs.filename }}
        key: ${{ steps.generate-keys.outputs.linux_key }}
        enableCrossOsArchive: true
        lookup-only: false
        fail-on-cache-miss: false

    # Try OS-specific pattern as fallback (finds latest matching cache)
    - name: üóÑÔ∏è Restore with Pattern
      id: cache-restore-pattern
      if: steps.cache-restore-exact.outputs.cache-hit != 'true' && steps.cache-restore-standard.outputs.cache-hit != 'true' && steps.cache-restore-agnostic.outputs.cache-hit != 'true' && steps.cache-restore-linux.outputs.cache-hit != 'true'
      uses: actions/cache/restore@v4
      env:
        ACTIONS_CACHE_SERVICE_V2: 'true'
      with:
        path: ${{ inputs.path }}/${{ inputs.filename }}
        key: ${{ steps.generate-keys.outputs.pattern_key || format('{0}-{1}-{2}-', runner.os, inputs.cache_key_prefix, inputs.name) }}
        restore-keys: |
          ${{ steps.generate-keys.outputs.pattern_key || format('{0}-{1}-{2}-', runner.os, inputs.cache_key_prefix, inputs.name) }}
        enableCrossOsArchive: true
        lookup-only: false
        fail-on-cache-miss: false

    # Verify pattern match is valid
    - name: üîç Verify Pattern Match
      id: verify-pattern
      if: steps.cache-restore-pattern.outputs.cache-hit == 'true'
      shell: bash
      run: |
        echo "::notice::Checking if pattern match produced a valid file..."

        if [ ! -f "${{ inputs.path }}/${{ inputs.filename }}" ]; then
          echo "::warning::Pattern match found but file does not exist"
          echo "valid=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Check file size
        FILE_SIZE=$(stat -c%s "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || stat -f%z "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || ls -l "${{ inputs.path }}/${{ inputs.filename }}" | awk '{print $5}')
        echo "::notice::Pattern match file size: ${FILE_SIZE} bytes"

        # Check if too small (< 10KB)
        if [ "$FILE_SIZE" -lt 10000 ]; then
          echo "::warning::Pattern match file is too small (${FILE_SIZE} bytes), considering it invalid"
          echo "valid=false" >> $GITHUB_OUTPUT
          # Remove the invalid file
          rm -f "${{ inputs.path }}/${{ inputs.filename }}"
        else
          echo "::notice::Pattern match file appears valid"
          echo "valid=true" >> $GITHUB_OUTPUT
        fi

    # Final attempt with OS-agnostic pattern
    - name: üóÑÔ∏è Restore with OS-Agnostic Pattern
      id: cache-restore-agnostic-pattern
      if: steps.cache-restore-exact.outputs.cache-hit != 'true' && steps.cache-restore-standard.outputs.cache-hit != 'true' && steps.cache-restore-agnostic.outputs.cache-hit != 'true' && steps.cache-restore-linux.outputs.cache-hit != 'true' && (steps.cache-restore-pattern.outputs.cache-hit != 'true' || steps.verify-pattern.outputs.valid != 'true')
      uses: actions/cache/restore@v4
      env:
        ACTIONS_CACHE_SERVICE_V2: 'true'
      with:
        path: ${{ inputs.path }}/${{ inputs.filename }}
        key: ${{ steps.generate-keys.outputs.agnostic_pattern || format('{0}-{1}-', inputs.cache_key_prefix, inputs.name) }}
        restore-keys: |
          ${{ steps.generate-keys.outputs.agnostic_pattern || format('{0}-{1}-', inputs.cache_key_prefix, inputs.name) }}
        enableCrossOsArchive: true
        lookup-only: false
        fail-on-cache-miss: false

    # Verify OS-agnostic pattern match is valid
    - name: üîç Verify OS-Agnostic Pattern Match
      id: verify-agnostic-pattern
      if: steps.cache-restore-agnostic-pattern.outputs.cache-hit == 'true'
      shell: bash
      run: |
        echo "::notice::Checking if OS-agnostic pattern match produced a valid file..."

        if [ ! -f "${{ inputs.path }}/${{ inputs.filename }}" ]; then
          echo "::warning::OS-agnostic pattern match found but file does not exist"
          echo "valid=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Check file size
        FILE_SIZE=$(stat -c%s "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || stat -f%z "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || ls -l "${{ inputs.path }}/${{ inputs.filename }}" | awk '{print $5}')
        echo "::notice::OS-agnostic pattern match file size: ${FILE_SIZE} bytes"

        # Check if too small (< 10KB)
        if [ "$FILE_SIZE" -lt 10000 ]; then
          echo "::warning::OS-agnostic pattern match file is too small (${FILE_SIZE} bytes), considering it invalid"
          echo "valid=false" >> $GITHUB_OUTPUT
          # Remove the invalid file
          rm -f "${{ inputs.path }}/${{ inputs.filename }}"
        else
          echo "::notice::OS-agnostic pattern match file appears valid"
          echo "valid=true" >> $GITHUB_OUTPUT
        fi

    # Absolute last resort - find any cache with the run ID
    - name: üóÑÔ∏è Restore with Run ID Pattern
      id: cache-restore-run-id
      if: steps.generate-keys.outputs.run_id_pattern != '' && steps.cache-restore-exact.outputs.cache-hit != 'true' && steps.cache-restore-standard.outputs.cache-hit != 'true' && steps.cache-restore-agnostic.outputs.cache-hit != 'true' && steps.cache-restore-linux.outputs.cache-hit != 'true' && (steps.cache-restore-pattern.outputs.cache-hit != 'true' || steps.verify-pattern.outputs.valid != 'true') && (steps.cache-restore-agnostic-pattern.outputs.cache-hit != 'true' || steps.verify-agnostic-pattern.outputs.valid != 'true')
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        ACTIONS_CACHE_SERVICE_V2: 'true'
      run: |
        echo "::notice::Attempting to find any cache with run ID: ${{ steps.generate-keys.outputs.run_id_pattern }}"

        # Get list of caches containing the run ID
        CACHE_LIST=$(gh cache list --json key,sizeInBytes --jq ".[] | select(.key | contains(\"${{ steps.generate-keys.outputs.run_id_pattern }}\")) | [.key, .sizeInBytes] | @tsv" || echo "")

        if [[ -n "${CACHE_LIST}" ]]; then
          echo "::notice::Found caches with matching run ID:"
          echo "${CACHE_LIST}"

          # Find the largest cache
          LARGEST_CACHE=$(echo "${CACHE_LIST}" | sort -k2 -nr | head -1)
          if [[ -n "${LARGEST_CACHE}" ]]; then
            CACHE_KEY=$(echo "${LARGEST_CACHE}" | cut -f1)
            CACHE_SIZE=$(echo "${LARGEST_CACHE}" | cut -f2)

            echo "::notice::Selected largest cache: ${CACHE_KEY} (${CACHE_SIZE} bytes)"
            echo "found_key=${CACHE_KEY}" >> $GITHUB_OUTPUT
            echo "cache-hit=false" >> $GITHUB_OUTPUT
          else
            echo "::warning::No valid cache with matching run ID"
            echo "cache-hit=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "::warning::No cache found with run ID: ${{ steps.generate-keys.outputs.run_id_pattern }}"
          echo "cache-hit=false" >> $GITHUB_OUTPUT
        fi

    # Verify Run ID pattern match is valid
    - name: üîç Verify Run ID Pattern Match
      id: verify-run-id
      if: steps.cache-restore-run-id.outputs.cache-hit == 'true'
      shell: bash
      run: |
        echo "::notice::Checking if Run ID pattern match produced a valid file..."

        if [ ! -f "${{ inputs.path }}/${{ inputs.filename }}" ]; then
          echo "::warning::Run ID pattern match found but file does not exist"
          echo "valid=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Check file size
        FILE_SIZE=$(stat -c%s "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || stat -f%z "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || ls -l "${{ inputs.path }}/${{ inputs.filename }}" | awk '{print $5}')
        echo "::notice::Run ID pattern match file size: ${FILE_SIZE} bytes"

        # Check if too small (< 10KB)
        if [ "$FILE_SIZE" -lt 10000 ]; then
          echo "::warning::Run ID pattern match file is too small (${FILE_SIZE} bytes), considering it invalid"
          echo "valid=false" >> $GITHUB_OUTPUT
          # Remove the invalid file
          rm -f "${{ inputs.path }}/${{ inputs.filename }}"
        else
          echo "::notice::Run ID pattern match file appears valid"
          echo "valid=true" >> $GITHUB_OUTPUT
        fi

    # Handle cache miss
    - name: ‚ö†Ô∏è Handle Cache Miss
      if: steps.cache-restore-exact.outputs.cache-hit != 'true' && steps.cache-restore-standard.outputs.cache-hit != 'true' && steps.cache-restore-agnostic.outputs.cache-hit != 'true' && steps.cache-restore-linux.outputs.cache-hit != 'true' && (steps.cache-restore-pattern.outputs.cache-hit != 'true' || steps.verify-pattern.outputs.valid != 'true') && (steps.cache-restore-agnostic-pattern.outputs.cache-hit != 'true' || steps.verify-agnostic-pattern.outputs.valid != 'true') && (steps.cache-restore-run-id.outputs.cache-hit != 'true' || steps.verify-run-id.outputs.valid != 'true')
      shell: bash
      run: |
        echo "::warning::No valid cache found for any of the following keys:"
        echo "::warning::  - Exact key: ${{ inputs.exact_cache_key || 'not provided' }}"
        echo "::warning::  - Standard key: ${{ steps.generate-keys.outputs.standard_key }} (hit: ${{ steps.cache-restore-standard.outputs.cache-hit || 'false' }})"
        echo "::warning::  - OS-Agnostic key: ${{ steps.generate-keys.outputs.agnostic_key }} (hit: ${{ steps.cache-restore-agnostic.outputs.cache-hit || 'false' }})"
        echo "::warning::  - Linux pattern: ${{ steps.generate-keys.outputs.linux_key }} (hit: ${{ steps.cache-restore-linux.outputs.cache-hit || 'false' }})"
        echo "::warning::  - Pattern key: ${{ steps.generate-keys.outputs.pattern_key }} (hit: ${{ steps.cache-restore-pattern.outputs.cache-hit || 'false' }}, valid: ${{ steps.verify-pattern.outputs.valid || 'unknown' }})"
        echo "::warning::  - OS-Agnostic pattern: ${{ steps.generate-keys.outputs.agnostic_pattern }} (hit: ${{ steps.cache-restore-agnostic-pattern.outputs.cache-hit || 'false' }}, valid: ${{ steps.verify-agnostic-pattern.outputs.valid || 'unknown' }})"
        echo "::warning::  - Run ID search: ${{ steps.generate-keys.outputs.run_id_pattern }} (hit: ${{ steps.cache-restore-run-id.outputs.cache-hit || 'false' }}, valid: ${{ steps.verify-run-id.outputs.valid || 'unknown' }})"
        echo "::warning::Trying alternative approaches..."

        # Create an empty file to prevent downstream failures
        mkdir -p $(dirname "${{ inputs.path }}/${{ inputs.filename }}")
        touch "${{ inputs.path }}/${{ inputs.filename }}"

    # Last resort with direct cache command
    - name: üîÑ Direct Cache Restore (Fallback)
      id: direct-cache-restore
      if: steps.file-check.outputs.valid != 'true'
      shell: bash
      run: |
        echo "::notice::Skipping direct cache restore approach"
        echo "success=false" >> $GITHUB_OUTPUT
      env:
        GH_TOKEN: ${{ github.token }}

    # Check if the file exists and has valid size/content before extraction
    - name: üîç Verify Downloaded File
      id: file-check
      shell: bash
      run: |
        echo "::notice::DOWNLOADED FILE DETAILS:"
        if [ -f "${{ inputs.path }}/${{ inputs.filename }}" ]; then
          echo "::notice::File exists: YES"

          # Check size
          FILE_SIZE=$(stat -c%s "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || stat -f%z "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || ls -l "${{ inputs.path }}/${{ inputs.filename }}" | awk '{print $5}')
          echo "::notice::File size: $(du -h "${{ inputs.path }}/${{ inputs.filename }}" | cut -f1) (${FILE_SIZE} bytes)"

          # Check if empty
          if [ "$FILE_SIZE" -gt 1000 ]; then
            echo "::notice::File is valid: YES"
            echo "valid=true" >> $GITHUB_OUTPUT

            # Try to verify zip integrity
            if unzip -t "${{ inputs.path }}/${{ inputs.filename }}" > /dev/null 2>&1; then
              echo "::notice::Zip integrity: VALID"
            else
              echo "::warning::Zip integrity check failed"
              echo "valid=false" >> $GITHUB_OUTPUT
              # Delete corrupted file
              rm -f "${{ inputs.path }}/${{ inputs.filename }}"
            fi
          else
            echo "::warning::File is too small (${FILE_SIZE} bytes)"
            echo "valid=false" >> $GITHUB_OUTPUT
            # Delete suspiciously small file
            rm -f "${{ inputs.path }}/${{ inputs.filename }}"
          fi
        else
          echo "::warning::File does not exist"
          echo "valid=false" >> $GITHUB_OUTPUT
        fi

        # Determine which cache hit actually worked
        if [ "${{ steps.cache-restore-exact.outputs.cache-hit }}" == "true" ]; then
          echo "::notice::Cache source: Exact key hit"
        elif [ "${{ steps.cache-restore-standard.outputs.cache-hit }}" == "true" ]; then
          echo "::notice::Cache source: Standard key hit"
        elif [ "${{ steps.cache-restore-agnostic.outputs.cache-hit }}" == "true" ]; then
          echo "::notice::Cache source: OS-agnostic key hit"
        elif [ "${{ steps.cache-restore-linux.outputs.cache-hit }}" == "true" ]; then
          echo "::notice::Cache source: Linux key hit"
        elif [ "${{ steps.cache-restore-pattern.outputs.cache-hit }}" == "true" ] && [ "${{ steps.verify-pattern.outputs.valid }}" == "true" ]; then
          echo "::notice::Cache source: Pattern key hit (verified)"
        elif [ "${{ steps.cache-restore-agnostic-pattern.outputs.cache-hit }}" == "true" ] && [ "${{ steps.verify-agnostic-pattern.outputs.valid }}" == "true" ]; then
          echo "::notice::Cache source: OS-agnostic pattern hit (verified)"
        elif [ "${{ steps.cache-restore-run-id.outputs.cache-hit }}" == "true" ] && [ "${{ steps.verify-run-id.outputs.valid }}" == "true" ]; then
          echo "::notice::Cache source: Run ID pattern search hit (verified)"
        elif [ "${{ steps.direct-cache-restore.outputs.success }}" == "true" ]; then
          echo "::notice::Cache source: Direct cache restore (fallback approach)"
        else
          echo "::warning::No valid cache hit detected"
        fi

    # Extract if cache was successfully restored
    - name: üìÇ Extract Compressed Archive
      if: steps.file-check.outputs.valid == 'true'
      shell: bash
      run: |
        echo "::notice::Extracting compressed artifact: ${{ inputs.path }}/${{ inputs.filename }}"
        cd "${{ inputs.path }}" && unzip -q -o "${{ inputs.filename }}"

    # Download from GitHub Artifacts with retries
    - name: üì• Download from GitHub Artifacts
      id: download-artifact
      if: steps.file-check.outputs.valid != 'true' && steps.direct-cache-restore.outputs.success != 'true' && inputs.use_cache != 'true-only'
      shell: bash
      run: |
        MAX_RETRIES=3
        RETRY_DELAY=5
        SUCCESS=false

        # Create output directory
        mkdir -p "${{ inputs.path }}"

        for i in $(seq 1 $MAX_RETRIES); do
          echo "::notice::Artifact download attempt $i of $MAX_RETRIES"

          # Use actions/download-artifact@v4 via gh run command
          gh run download -n "${{ inputs.name }}.zip" -D "${{ inputs.path }}" || true

          # Check if the download was successful
          if find "${{ inputs.path }}" -type f -name "*.zip" | grep -q .; then
            echo "::notice::Successfully downloaded artifact on attempt $i"
            SUCCESS=true
            break
          else
            echo "::warning::Artifact download failed on attempt $i"
            if [ $i -lt $MAX_RETRIES ]; then
              echo "::notice::Waiting ${RETRY_DELAY}s before next attempt..."
              sleep $RETRY_DELAY
              # Increase delay for next retry
              RETRY_DELAY=$((RETRY_DELAY * 2))
            fi
          fi
        done

        if [ "$SUCCESS" = "true" ]; then
          echo "outcome=success" >> $GITHUB_OUTPUT
        else
          echo "::warning::All artifact download attempts failed"
          echo "outcome=failure" >> $GITHUB_OUTPUT
        fi
      env:
        GH_TOKEN: ${{ github.token }}

    # Find and move the artifact file if needed
    - name: üîÑ Find and Move Artifact
      id: find-artifact
      if: (steps.download-artifact.outcome == 'success' || steps.download-artifact.outputs.outcome == 'success')
      shell: bash
      run: |
        echo "::notice::Checking for downloaded artifact"

        # First check if our expected file exists
        if [ -f "${{ inputs.path }}/${{ inputs.filename }}" ]; then
          echo "::notice::Artifact found at expected location: ${{ inputs.path }}/${{ inputs.filename }}"
          echo "found=true" >> $GITHUB_OUTPUT
          exit 0
        fi

        echo "::notice::Searching for artifact files in downloaded directory"

        # Find zip files in the download directory
        ZIP_FILES=$(find "${{ inputs.path }}" -type f -name "*.zip" -not -path "*/\.*" 2>/dev/null || echo "")
        if [ -n "$ZIP_FILES" ]; then
          # Count how many files we found
          COUNT=$(echo "$ZIP_FILES" | wc -l | tr -d ' ')
          echo "::notice::Found $COUNT zip file(s) in download directory"

          # Get the first file
          FIRST_ZIP=$(echo "$ZIP_FILES" | head -1)

          # If it's not at the expected location, move it
          if [ "$FIRST_ZIP" != "${{ inputs.path }}/${{ inputs.filename }}" ]; then
            echo "::notice::Moving $FIRST_ZIP to ${{ inputs.path }}/${{ inputs.filename }}"
            mv "$FIRST_ZIP" "${{ inputs.path }}/${{ inputs.filename }}"
          fi

          echo "found=true" >> $GITHUB_OUTPUT
        else
          echo "::warning::No zip files found in download directory"
          echo "found=false" >> $GITHUB_OUTPUT

          # List all files recursively for debugging
          echo "::notice::Listing all files in download directory:"
          find "${{ inputs.path }}" -type f -not -path "*/\.*" | xargs ls -la 2>/dev/null || echo "No files found"
        fi

    # Re-verify after artifact download
    - name: üîç Verify Downloaded Artifact
      id: artifact-check
      if: (steps.download-artifact.outcome == 'success' || steps.download-artifact.outputs.outcome == 'success') && steps.find-artifact.outputs.found == 'true'
      shell: bash
      run: |
        echo "::notice::Checking downloaded artifact"
        if [ -f "${{ inputs.path }}/${{ inputs.filename }}" ]; then
          echo "::notice::Artifact exists: YES"

          # Check size
          FILE_SIZE=$(stat -c%s "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || stat -f%z "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || ls -l "${{ inputs.path }}/${{ inputs.filename }}" | awk '{print $5}')
          echo "::notice::Artifact size: $(du -h "${{ inputs.path }}/${{ inputs.filename }}" | cut -f1) (${FILE_SIZE} bytes)"

          # Check if empty
          if [ "$FILE_SIZE" -gt 1000 ]; then
            echo "::notice::Artifact downloaded successfully from GitHub Artifacts"
            echo "valid=true" >> $GITHUB_OUTPUT
          else
            echo "::warning::Downloaded artifact is too small (${FILE_SIZE} bytes)"
            echo "valid=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "::warning::No artifact found at path: ${{ inputs.path }}/${{ inputs.filename }}"
          echo "valid=false" >> $GITHUB_OUTPUT
        fi

    # Extract if artifact download was successful
    - name: ÔøΩÔøΩ Extract Downloaded Artifact
      if: steps.artifact-check.outputs.valid == 'true'
      shell: bash
      run: |
        echo "::notice::Extracting downloaded artifact: ${{ inputs.path }}/${{ inputs.filename }}"
        cd "${{ inputs.path }}" && unzip -q -o "${{ inputs.filename }}"
