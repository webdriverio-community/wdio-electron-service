name: 'Download and Extract Artifacts'
description: 'Downloads and extracts compressed artifacts shared from previous jobs using GitHub cache (90-day retention)'
inputs:
  path:
    description: 'Destination directory to extract the artifact contents'
    required: true
  filename:
    description: 'Filename of the compressed artifact to download'
    required: true
    default: 'artifact.zip'
  name:
    description: 'Artifact name as used in the cache key'
    required: true
  cache_key_prefix:
    description: 'Prefix for the cache key (must match upload setting)'
    default: 'build-artifacts'
    required: false
  exact_cache_key:
    description: 'Exact cache key to use for retrieval (if provided)'
    required: false
  use_cache:
    description: 'Use cache only (true-only or false-only)'
    required: false
runs:
  using: 'composite'
  steps:
    # Generate standard cache keys
    - name: üîë Generate Cache Keys
      id: generate-keys
      shell: bash
      run: |
        # Ensure values have defaults
        CACHE_PREFIX="${{ inputs.cache_key_prefix || 'artifacts' }}"
        NAME="${{ inputs.name }}"
        OS="${{ runner.os }}"
        RUN_ID="${{ github.run_id }}"

        # Generate standard key (os-specific)
        STANDARD_KEY="${OS}-${CACHE_PREFIX}-${NAME}-${RUN_ID}"
        echo "standard_key=${STANDARD_KEY}" >> $GITHUB_OUTPUT
        echo "::notice::Standard key: ${STANDARD_KEY}"

        # Generate OS-agnostic key
        AGNOSTIC_KEY="${CACHE_PREFIX}-${NAME}-${RUN_ID}"
        echo "agnostic_key=${AGNOSTIC_KEY}" >> $GITHUB_OUTPUT
        echo "::notice::OS-agnostic key: ${AGNOSTIC_KEY}"

        # Generate Linux-specific key for cross-OS compatibility
        LINUX_KEY="Linux-${CACHE_PREFIX}-${NAME}-${RUN_ID}"
        echo "linux_key=${LINUX_KEY}" >> $GITHUB_OUTPUT
        echo "::notice::Linux key: ${LINUX_KEY}"

        # Generate pattern keys
        PATTERN_KEY="${OS}-${CACHE_PREFIX}-${NAME}-"
        echo "pattern_key=${PATTERN_KEY}" >> $GITHUB_OUTPUT
        echo "::notice::Pattern key: ${PATTERN_KEY}"

        # Generate OS-agnostic pattern
        AGNOSTIC_PATTERN="${CACHE_PREFIX}-${NAME}-"
        echo "agnostic_pattern=${AGNOSTIC_PATTERN}" >> $GITHUB_OUTPUT
        echo "::notice::OS-agnostic pattern: ${AGNOSTIC_PATTERN}"

    # List available caches for debugging
    - name: üìã List Available Caches
      id: list-caches
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        ACTIONS_CACHE_SERVICE_V2: 'true'
      run: |
        echo "::notice::===== AVAILABLE CACHES ====="
        gh cache list --limit 20 || echo "::warning::Unable to list caches with GH CLI"

    # Restore cache with exact key (if provided)
    - name: üóÑÔ∏è Restore with Exact Key
      id: cache-restore-exact
      if: inputs.exact_cache_key != ''
      uses: actions/cache/restore@v4
      env:
        ACTIONS_CACHE_SERVICE_V2: 'true'
      with:
        path: ${{ inputs.path }}/${{ inputs.filename }}
        key: ${{ inputs.exact_cache_key }}
        enableCrossOsArchive: true
        lookup-only: false
        fail-on-cache-miss: false

    # Restore with standard key (os-specific)
    - name: üóÑÔ∏è Restore with Standard Key
      id: cache-restore-standard
      if: steps.cache-restore-exact.outputs.cache-hit != 'true'
      uses: actions/cache/restore@v4
      env:
        ACTIONS_CACHE_SERVICE_V2: 'true'
      with:
        path: ${{ inputs.path }}/${{ inputs.filename }}
        key: ${{ steps.generate-keys.outputs.standard_key }}
        enableCrossOsArchive: true
        lookup-only: false
        fail-on-cache-miss: false

    # Restore with OS-agnostic key
    - name: üóÑÔ∏è Restore with OS-Agnostic Key
      id: cache-restore-agnostic
      if: steps.cache-restore-exact.outputs.cache-hit != 'true' && steps.cache-restore-standard.outputs.cache-hit != 'true'
      uses: actions/cache/restore@v4
      env:
        ACTIONS_CACHE_SERVICE_V2: 'true'
      with:
        path: ${{ inputs.path }}/${{ inputs.filename }}
        key: ${{ steps.generate-keys.outputs.agnostic_key }}
        enableCrossOsArchive: true
        lookup-only: false
        fail-on-cache-miss: false

    # Restore with Linux key for cross-OS compatibility
    - name: üóÑÔ∏è Restore with Linux Key
      id: cache-restore-linux
      if: steps.cache-restore-exact.outputs.cache-hit != 'true' && steps.cache-restore-standard.outputs.cache-hit != 'true' && steps.cache-restore-agnostic.outputs.cache-hit != 'true' && runner.os != 'Linux'
      uses: actions/cache/restore@v4
      env:
        ACTIONS_CACHE_SERVICE_V2: 'true'
      with:
        path: ${{ inputs.path }}/${{ inputs.filename }}
        key: ${{ steps.generate-keys.outputs.linux_key }}
        enableCrossOsArchive: true
        lookup-only: false
        fail-on-cache-miss: false

    # Try OS-specific pattern as fallback (finds latest matching cache)
    - name: üóÑÔ∏è Restore with Pattern
      id: cache-restore-pattern
      if: steps.cache-restore-exact.outputs.cache-hit != 'true' && steps.cache-restore-standard.outputs.cache-hit != 'true' && steps.cache-restore-agnostic.outputs.cache-hit != 'true' && steps.cache-restore-linux.outputs.cache-hit != 'true'
      uses: actions/cache/restore@v4
      env:
        ACTIONS_CACHE_SERVICE_V2: 'true'
      with:
        path: ${{ inputs.path }}/${{ inputs.filename }}
        key: ${{ steps.generate-keys.outputs.pattern_key || format('{0}-{1}-{2}-', runner.os, inputs.cache_key_prefix, inputs.name) }}
        restore-keys: |
          ${{ steps.generate-keys.outputs.pattern_key || format('{0}-{1}-{2}-', runner.os, inputs.cache_key_prefix, inputs.name) }}
        enableCrossOsArchive: true
        lookup-only: false
        fail-on-cache-miss: false

    # Verify pattern match is valid
    - name: üîç Verify Pattern Match
      id: verify-pattern
      if: steps.cache-restore-pattern.outputs.cache-hit == 'true'
      shell: bash
      run: |
        echo "::notice::Checking if pattern match produced a valid file..."

        if [ ! -f "${{ inputs.path }}/${{ inputs.filename }}" ]; then
          echo "::warning::Pattern match found but file does not exist"
          echo "valid=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Check file size
        FILE_SIZE=$(stat -c%s "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || stat -f%z "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || ls -l "${{ inputs.path }}/${{ inputs.filename }}" | awk '{print $5}')
        echo "::notice::Pattern match file size: ${FILE_SIZE} bytes"

        # Check if too small (< 10KB)
        if [ "$FILE_SIZE" -lt 10000 ]; then
          echo "::warning::Pattern match file is too small (${FILE_SIZE} bytes), considering it invalid"
          echo "valid=false" >> $GITHUB_OUTPUT
          # Remove the invalid file
          rm -f "${{ inputs.path }}/${{ inputs.filename }}"
        else
          echo "::notice::Pattern match file appears valid"
          echo "valid=true" >> $GITHUB_OUTPUT
        fi

    # Final attempt with OS-agnostic pattern
    - name: üóÑÔ∏è Restore with OS-Agnostic Pattern
      id: cache-restore-agnostic-pattern
      if: steps.cache-restore-exact.outputs.cache-hit != 'true' && steps.cache-restore-standard.outputs.cache-hit != 'true' && steps.cache-restore-agnostic.outputs.cache-hit != 'true' && steps.cache-restore-linux.outputs.cache-hit != 'true' && (steps.cache-restore-pattern.outputs.cache-hit != 'true' || steps.verify-pattern.outputs.valid != 'true')
      uses: actions/cache/restore@v4
      env:
        ACTIONS_CACHE_SERVICE_V2: 'true'
      with:
        path: ${{ inputs.path }}/${{ inputs.filename }}
        key: ${{ steps.generate-keys.outputs.agnostic_pattern || format('{0}-{1}-', inputs.cache_key_prefix, inputs.name) }}
        restore-keys: |
          ${{ steps.generate-keys.outputs.agnostic_pattern || format('{0}-{1}-', inputs.cache_key_prefix, inputs.name) }}
        enableCrossOsArchive: true
        lookup-only: false
        fail-on-cache-miss: false

    # Verify OS-agnostic pattern match is valid
    - name: üîç Verify OS-Agnostic Pattern Match
      id: verify-agnostic-pattern
      if: steps.cache-restore-agnostic-pattern.outputs.cache-hit == 'true'
      shell: bash
      run: |
        echo "::notice::Checking if OS-agnostic pattern match produced a valid file..."

        if [ ! -f "${{ inputs.path }}/${{ inputs.filename }}" ]; then
          echo "::warning::OS-agnostic pattern match found but file does not exist"
          echo "valid=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Check file size
        FILE_SIZE=$(stat -c%s "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || stat -f%z "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || ls -l "${{ inputs.path }}/${{ inputs.filename }}" | awk '{print $5}')
        echo "::notice::OS-agnostic pattern match file size: ${FILE_SIZE} bytes"

        # Check if too small (< 10KB)
        if [ "$FILE_SIZE" -lt 10000 ]; then
          echo "::warning::OS-agnostic pattern match file is too small (${FILE_SIZE} bytes), considering it invalid"
          echo "valid=false" >> $GITHUB_OUTPUT
          # Remove the invalid file
          rm -f "${{ inputs.path }}/${{ inputs.filename }}"
        else
          echo "::notice::OS-agnostic pattern match file appears valid"
          echo "valid=true" >> $GITHUB_OUTPUT
        fi

    # Absolute last resort - find any cache with the run ID
    - name: üóÑÔ∏è Restore with Run ID Pattern
      id: cache-restore-run-id
      if: steps.generate-keys.outputs.run_id_pattern != '' && steps.cache-restore-exact.outputs.cache-hit != 'true' && steps.cache-restore-standard.outputs.cache-hit != 'true' && steps.cache-restore-agnostic.outputs.cache-hit != 'true' && steps.cache-restore-linux.outputs.cache-hit != 'true' && (steps.cache-restore-pattern.outputs.cache-hit != 'true' || steps.verify-pattern.outputs.valid != 'true') && (steps.cache-restore-agnostic-pattern.outputs.cache-hit != 'true' || steps.verify-agnostic-pattern.outputs.valid != 'true')
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        ACTIONS_CACHE_SERVICE_V2: 'true'
      run: |
        echo "::notice::Attempting to find any cache with run ID: ${{ steps.generate-keys.outputs.run_id_pattern }}"

        # Get list of caches containing the run ID
        CACHE_LIST=$(gh cache list --json key,sizeInBytes --jq ".[] | select(.key | contains(\"${{ steps.generate-keys.outputs.run_id_pattern }}\")) | [.key, .sizeInBytes] | @tsv" || echo "")

        if [[ -n "${CACHE_LIST}" ]]; then
          echo "::notice::Found caches with matching run ID:"
          echo "${CACHE_LIST}"

          # Find the largest cache
          LARGEST_CACHE=$(echo "${CACHE_LIST}" | sort -k2 -nr | head -1)
          if [[ -n "${LARGEST_CACHE}" ]]; then
            CACHE_KEY=$(echo "${LARGEST_CACHE}" | cut -f1)
            CACHE_SIZE=$(echo "${LARGEST_CACHE}" | cut -f2)

            echo "::notice::Selected largest cache: ${CACHE_KEY} (${CACHE_SIZE} bytes)"
            echo "found_key=${CACHE_KEY}" >> $GITHUB_OUTPUT
            echo "cache-hit=false" >> $GITHUB_OUTPUT
          else
            echo "::warning::No valid cache with matching run ID"
            echo "cache-hit=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "::warning::No cache found with run ID: ${{ steps.generate-keys.outputs.run_id_pattern }}"
          echo "cache-hit=false" >> $GITHUB_OUTPUT
        fi

    # Verify Run ID pattern match is valid
    - name: üîç Verify Run ID Pattern Match
      id: verify-run-id
      if: steps.cache-restore-run-id.outputs.cache-hit == 'true'
      shell: bash
      run: |
        echo "::notice::Checking if Run ID pattern match produced a valid file..."

        if [ ! -f "${{ inputs.path }}/${{ inputs.filename }}" ]; then
          echo "::warning::Run ID pattern match found but file does not exist"
          echo "valid=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Check file size
        FILE_SIZE=$(stat -c%s "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || stat -f%z "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || ls -l "${{ inputs.path }}/${{ inputs.filename }}" | awk '{print $5}')
        echo "::notice::Run ID pattern match file size: ${FILE_SIZE} bytes"

        # Check if too small (< 10KB)
        if [ "$FILE_SIZE" -lt 10000 ]; then
          echo "::warning::Run ID pattern match file is too small (${FILE_SIZE} bytes), considering it invalid"
          echo "valid=false" >> $GITHUB_OUTPUT
          # Remove the invalid file
          rm -f "${{ inputs.path }}/${{ inputs.filename }}"
        else
          echo "::notice::Run ID pattern match file appears valid"
          echo "valid=true" >> $GITHUB_OUTPUT
        fi

    # Handle cache miss
    - name: ‚ö†Ô∏è Handle Cache Miss
      if: steps.cache-restore-exact.outputs.cache-hit != 'true' && steps.cache-restore-standard.outputs.cache-hit != 'true' && steps.cache-restore-agnostic.outputs.cache-hit != 'true' && steps.cache-restore-linux.outputs.cache-hit != 'true' && (steps.cache-restore-pattern.outputs.cache-hit != 'true' || steps.verify-pattern.outputs.valid != 'true') && (steps.cache-restore-agnostic-pattern.outputs.cache-hit != 'true' || steps.verify-agnostic-pattern.outputs.valid != 'true') && (steps.cache-restore-run-id.outputs.cache-hit != 'true' || steps.verify-run-id.outputs.valid != 'true')
      shell: bash
      run: |
        echo "::warning::No valid cache found for any of the following keys:"
        echo "::warning::  - Exact key: ${{ inputs.exact_cache_key || 'not provided' }}"
        echo "::warning::  - Standard key: ${{ steps.generate-keys.outputs.standard_key }} (hit: ${{ steps.cache-restore-standard.outputs.cache-hit || 'false' }})"
        echo "::warning::  - OS-Agnostic key: ${{ steps.generate-keys.outputs.agnostic_key }} (hit: ${{ steps.cache-restore-agnostic.outputs.cache-hit || 'false' }})"
        echo "::warning::  - Linux pattern: ${{ steps.generate-keys.outputs.linux_key }} (hit: ${{ steps.cache-restore-linux.outputs.cache-hit || 'false' }})"
        echo "::warning::  - Pattern key: ${{ steps.generate-keys.outputs.pattern_key }} (hit: ${{ steps.cache-restore-pattern.outputs.cache-hit || 'false' }}, valid: ${{ steps.verify-pattern.outputs.valid || 'unknown' }})"
        echo "::warning::  - OS-Agnostic pattern: ${{ steps.generate-keys.outputs.agnostic_pattern }} (hit: ${{ steps.cache-restore-agnostic-pattern.outputs.cache-hit || 'false' }}, valid: ${{ steps.verify-agnostic-pattern.outputs.valid || 'unknown' }})"
        echo "::warning::  - Run ID search: ${{ steps.generate-keys.outputs.run_id_pattern }} (hit: ${{ steps.cache-restore-run-id.outputs.cache-hit || 'false' }}, valid: ${{ steps.verify-run-id.outputs.valid || 'unknown' }})"
        echo "::warning::Trying alternative approaches..."

        # Create an empty file to prevent downstream failures
        mkdir -p $(dirname "${{ inputs.path }}/${{ inputs.filename }}")
        touch "${{ inputs.path }}/${{ inputs.filename }}"

    # Check if the file exists and has valid size/content before extraction
    - name: üîç Verify Downloaded File
      id: file-check
      shell: bash
      run: |
        echo "::notice::DOWNLOADED FILE DETAILS:"
        # Mark as invalid by default
        echo "valid=false" >> $GITHUB_OUTPUT

        if [ -f "${{ inputs.path }}/${{ inputs.filename }}" ]; then
          echo "::notice::File exists: YES"

          # Check size
          FILE_SIZE=$(stat -c%s "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || stat -f%z "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || ls -l "${{ inputs.path }}/${{ inputs.filename }}" | awk '{print $5}')
          echo "::notice::File size: $(du -h "${{ inputs.path }}/${{ inputs.filename }}" | cut -f1) (${FILE_SIZE} bytes)"

          # Check if empty
          if [ "$FILE_SIZE" -gt 1000 ]; then
            # Try to verify zip integrity
            if unzip -t "${{ inputs.path }}/${{ inputs.filename }}" > /dev/null 2>&1; then
              echo "::notice::Zip integrity: VALID"
              echo "valid=true" >> $GITHUB_OUTPUT
            else
              echo "::warning::Zip integrity check failed"
              # Delete corrupted file
              rm -f "${{ inputs.path }}/${{ inputs.filename }}"
            fi
          else
            echo "::warning::File is too small (${FILE_SIZE} bytes)"
            # Delete suspiciously small file
            rm -f "${{ inputs.path }}/${{ inputs.filename }}"
          fi
        else
          echo "::warning::File does not exist"
        fi

        # Determine which cache hit actually worked
        if [ "${{ steps.cache-restore-exact.outputs.cache-hit }}" == "true" ]; then
          echo "::notice::Cache source: Exact key hit"
        elif [ "${{ steps.cache-restore-standard.outputs.cache-hit }}" == "true" ]; then
          echo "::notice::Cache source: Standard key hit"
        elif [ "${{ steps.cache-restore-agnostic.outputs.cache-hit }}" == "true" ]; then
          echo "::notice::Cache source: OS-Agnostic key hit"
        elif [ "${{ steps.cache-restore-linux.outputs.cache-hit }}" == "true" ]; then
          echo "::notice::Cache source: Linux key hit"
        elif [ "${{ steps.cache-restore-pattern.outputs.cache-hit }}" == "true" ] && [ "${{ steps.verify-pattern.outputs.valid }}" == "true" ]; then
          echo "::notice::Cache source: Pattern key hit (verified)"
        elif [ "${{ steps.cache-restore-agnostic-pattern.outputs.cache-hit }}" == "true" ] && [ "${{ steps.verify-agnostic-pattern.outputs.valid }}" == "true" ]; then
          echo "::notice::Cache source: OS-agnostic pattern hit (verified)"
        elif [ "${{ steps.cache-restore-run-id.outputs.cache-hit }}" == "true" ] && [ "${{ steps.verify-run-id.outputs.valid }}" == "true" ]; then
          echo "::notice::Cache source: Run ID pattern search hit (verified)"
        elif [ "${{ steps.direct-cache-restore.outputs.success }}" == "true" ]; then
          echo "::notice::Cache source: Direct cache restore (fallback approach)"
        else
          echo "::warning::No valid cache hit detected"
        fi

    # Download from GitHub Artifacts as fallback
    - name: üì• Download from GitHub Artifacts
      id: download-artifact
      if: steps.file-check.outputs.valid != 'true' && inputs.use_cache != 'true-only'
      shell: bash
      run: |
        echo "::notice::Cache not found, attempting to download from GitHub Artifacts..."
        # Create output directory
        mkdir -p "${{ inputs.path }}"

        # Add retry logic for reliability
        MAX_RETRIES=3
        for i in $(seq 1 $MAX_RETRIES); do
          echo "::notice::Artifact download attempt $i of $MAX_RETRIES"

          # Use actions/download-artifact via gh run command
          gh run download -n "${{ inputs.name }}.zip" -D "${{ inputs.path }}" && DOWNLOAD_SUCCESS=true || DOWNLOAD_SUCCESS=false

          if [ "$DOWNLOAD_SUCCESS" = "true" ] || find "${{ inputs.path }}" -type f -name "*.zip" | grep -q .; then
            echo "::notice::Successfully downloaded artifact on attempt $i"
            break
          elif [ $i -lt $MAX_RETRIES ]; then
            echo "::warning::Artifact download failed on attempt $i, retrying in $((i * 5))s..."
            sleep $((i * 5))
          else
            echo "::warning::All artifact download attempts failed"
          fi
        done

        # Find and move ZIP files if needed
        ZIP_FILES=$(find "${{ inputs.path }}" -type f -name "*.zip" -not -path "*/\.*" 2>/dev/null)
        if [ -n "$ZIP_FILES" ]; then
          FIRST_ZIP=$(echo "$ZIP_FILES" | head -1)
          if [ "$FIRST_ZIP" != "${{ inputs.path }}/${{ inputs.filename }}" ]; then
            echo "::notice::Moving $FIRST_ZIP to ${{ inputs.path }}/${{ inputs.filename }}"
            mv "$FIRST_ZIP" "${{ inputs.path }}/${{ inputs.filename }}"
          fi

          # Verify downloaded artifact
          if [ -f "${{ inputs.path }}/${{ inputs.filename }}" ]; then
            FILE_SIZE=$(stat -c%s "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || stat -f%z "${{ inputs.path }}/${{ inputs.filename }}" 2>/dev/null || ls -l "${{ inputs.path }}/${{ inputs.filename }}" | awk '{print $5}')
            if [ "$FILE_SIZE" -gt 1000 ]; then
              echo "valid=true" >> $GITHUB_OUTPUT
            else
              echo "::warning::Downloaded artifact is too small: ${FILE_SIZE} bytes"
            fi
          fi
        fi
      env:
        GH_TOKEN: ${{ github.token }}

    # Extract if any method was successful
    - name: üìÇ Extract Compressed Archive
      id: extract-archive
      if: steps.file-check.outputs.valid == 'true' || steps.download-artifact.outputs.valid == 'true'
      shell: bash
      run: |
        echo "::notice::Extracting compressed artifact: ${{ inputs.path }}/${{ inputs.filename }}"

        # Show archive contents before extraction
        echo "::notice::Archive contents summary:"
        unzip -l "${{ inputs.path }}/${{ inputs.filename }}" | head -n 10
        echo "... (truncated) ..."
        unzip -l "${{ inputs.path }}/${{ inputs.filename }}" | tail -n 5

        # Extract to the workspace root
        echo "::notice::Extraction in progress..."
        cd "${{ github.workspace }}" && unzip -o "${{ inputs.path }}/${{ inputs.filename }}" -d "${{ github.workspace }}"

        # Verify extraction success
        EXTRACT_STATUS=$?
        if [ $EXTRACT_STATUS -eq 0 ]; then
          echo "::notice::‚úÖ Extraction completed successfully"
          echo "success=true" >> $GITHUB_OUTPUT

          # Provide basic info about extracted files
          echo "::notice::Extract verification:"
          echo "::notice::- Workspace root contents:"
          ls -la "${{ github.workspace }}" | head -n 10

          echo "::notice::- Packages directory contents:"
          ls -la "${{ github.workspace }}/packages" 2>/dev/null || echo "packages directory not found"

          echo "::notice::- Found dist directories:"
          find "${{ github.workspace }}" -name "dist" -type d | head -n 10 || echo "No dist directories found"
        else
          echo "::error::‚ùå Extraction failed with status code: ${EXTRACT_STATUS}"
          echo "success=false" >> $GITHUB_OUTPUT
        fi
