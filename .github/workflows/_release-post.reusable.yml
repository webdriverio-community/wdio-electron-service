name: Post-Release Tasks

on:
  workflow_call:
    inputs:
      branch_type:
        description: 'Branch type (main, feature, maintenance)'
        required: true
        type: string
      target_branch:
        description: 'Target branch to release from'
        required: true
        type: string
      next_lts_branch:
        description: 'Next LTS branch name'
        required: true
        type: string
      release_version:
        description: 'Release type (patch, minor, major, prepatch, preminor, premajor, prerelease)'
        required: true
        type: string
      release_tag:
        description: 'Release tag (e.g. v8.1.1)'
        required: true
        type: string
      dry_run:
        description: 'Do not touch or write anything. Show the commands.'
        required: true
        default: false
        type: boolean
    secrets:
      github_bot_token:
        description: 'GitHub token for authentication'
        required: true
      deploy_key:
        description: 'SSH deploy key for pushing to the repository'
        required: true

jobs:
  post-release:
    runs-on: ubuntu-latest
    steps:
      - name: 👷 Checkout target branch
        uses: actions/checkout@v5
        with:
          ssh-key: ${{ secrets.deploy_key }}
          ref: ${{ inputs.target_branch }}
          fetch-depth: 0 # Full history needed for versioning

      - name: 🛠️ Setup workspace
        uses: ./.github/workflows/actions/setup-workspace
        with:
          node-version: '20'

      - name: 🚧 Create LTS branch and merge feature branch
        shell: bash
        env:
          NEW_LTS_BRANCH: ${{ inputs.next_lts_branch }}
        run: |
          if [[ "${{ inputs.dry_run }}" == "true" ]]; then
            if [[ "${{ contains(inputs.release_version, 'major') && !contains(inputs.release_version, 'pre') }}" == "true" ]]; then
              if [[ "${{ inputs.branch_type }}" == "feature" ]]; then
                echo "DRY RUN: Would create LTS branch ${NEW_LTS_BRANCH} from main before merge"
                echo "DRY RUN: Would merge ${{ inputs.target_branch }} to main"
              else
                echo "DRY RUN: Would create LTS branch ${NEW_LTS_BRANCH} from current commit"
              fi
            else
              echo "DRY RUN: Not a major release, would skip LTS branch creation"
            fi
          else
            if [[ "${{ contains(inputs.release_version, 'major') && !contains(inputs.release_version, 'pre') }}" == "true" ]]; then
              echo "::group::Creating LTS branch and handling feature merge"
              
              if [[ "${{ inputs.branch_type }}" == "feature" ]]; then
                # For feature branch releases, create LTS branch from main before merge
                if git ls-remote --heads origin ${NEW_LTS_BRANCH} | grep -q ${NEW_LTS_BRANCH}; then
                  echo "The LTS branch ${NEW_LTS_BRANCH} already exists remotely."
                else
                  # Fetch the latest main branch
                  git fetch origin main
                  
                  # Create LTS branch from current main (before the merge)
                  git checkout origin/main -b ${NEW_LTS_BRANCH}
                  
                  # Use the TypeScript script to update documentation
                  pnpx tsx scripts/update-maintenance-docs.ts maintenance ${NEW_LTS_BRANCH}
                  
                  # Stage and commit the changes
                  git add MAINTENANCE.md README.md
                  git commit -m "docs: add maintenance branch information to README.md and MAINTENANCE.md [skip ci]"
                  
                  echo "✅ Created LTS branch ${NEW_LTS_BRANCH} from main before merge"
                  
                  # Return to the feature branch
                  git checkout ${{ inputs.target_branch }}
                fi
                
                # Now merge the feature branch to main
                echo "Merging feature branch to main..."
                
                # Ensure we have the latest main branch
                git fetch origin main
                
                # Create a temporary branch from main to merge into
                git checkout origin/main -b temp-main-for-merge
                
                # Set git identity for potential conflict resolution commits
                git config user.email "bot@webdriver.io"
                git config user.name "WebdriverIO Release Bot"
                
                # Get the correct version for the commit message (from the release tag)
                RELEASE_VERSION=$(jq -r '.version' packages/wdio-electron-service/package.json)
                
                # Try to merge the feature branch into the temp branch
                # Using --no-ff to ensure a merge commit is created
                if ! git merge --no-ff ${{ inputs.target_branch }} -m "feat: merge ${{ inputs.target_branch }} to main for v${RELEASE_VERSION} release [skip ci]"; then
                  echo "::error::Merge conflict detected when merging ${{ inputs.target_branch }} to main"
                  
                  # Abort the merge
                  git merge --abort
                  
                  # Create a detailed error message
                  echo "::group::Merge Conflict Details"
                  echo "The automated merge from ${{ inputs.target_branch }} to main failed due to conflicts."
                  echo "Please resolve these conflicts manually by:"
                  echo "1. Creating a PR from ${{ inputs.target_branch }} to main"
                  echo "2. Resolving the conflicts in the PR"
                  echo "3. Merging the PR"
                  echo "4. Then run this release workflow again from the main branch"
                  echo "::endgroup::"
                  
                  # Return to the original branch
                  git checkout ${{ inputs.target_branch }}
                  
                  # Exit with error
                  exit 1
                fi
                
                # If we get here, the merge was successful
                echo "Successfully merged ${{ inputs.target_branch }} to temp-main-for-merge"
                
                # Set a flag to indicate successful merge
                echo "MERGE_SUCCESSFUL=true" >> $GITHUB_ENV
                
                # Return to the original branch for the rest of the release process
                git checkout ${{ inputs.target_branch }}
                
              else
                # For main branch releases, create LTS branch from current commit
                if git ls-remote --heads origin ${NEW_LTS_BRANCH} | grep -q ${NEW_LTS_BRANCH}; then
                  echo "The LTS branch ${NEW_LTS_BRANCH} already exists remotely."
                else
                  echo "Creating LTS branch ${NEW_LTS_BRANCH} from current commit..."
                  git branch ${NEW_LTS_BRANCH}
                  
                  # Switch to the new branch to add documentation
                  git checkout ${NEW_LTS_BRANCH}
                  
                  # Use the TypeScript script to update documentation
                  pnpx tsx scripts/update-maintenance-docs.ts maintenance ${NEW_LTS_BRANCH}
                  
                  # Stage and commit the changes
                  git add MAINTENANCE.md README.md
                  git commit -m "docs: add maintenance branch information to README.md and MAINTENANCE.md [skip ci]"
                  
                  echo "✅ Created LTS branch ${NEW_LTS_BRANCH} from current commit"
                  
                  # Return to the original branch
                  git checkout ${{ inputs.target_branch }}
                fi
              fi
              
              echo "::endgroup::"
            else
              echo "Not a major release, skipping LTS branch creation"
            fi
          fi

      - name: 🔄 Update dependabot configuration
        # Update dependabot config for major releases, but not for prereleases
        if: ${{ contains(inputs.release_version, 'major') && !contains(inputs.release_version, 'pre') }}
        shell: bash
        env:
          NEW_LTS_BRANCH: ${{ inputs.next_lts_branch }}
          CONFIG_DEPENDABOT: '.github/dependabot.yml'
        run: |
          if [[ "${{ inputs.dry_run }}" == "true" ]]; then
            echo "DRY RUN: Would update dependabot configuration for ${NEW_LTS_BRANCH}"
          else
            echo '::group::Updating the configuration of dependabot'
            # Update the target-branch in dependabot.yml to point to the new LTS branch
            yq e "(.. | select(has(\"target-branch\"))
                      | select(.[\"target-branch\"]
                      | test(\"^v[0-9]+$\"))).target-branch = \"${NEW_LTS_BRANCH}\"" \
              -i "${CONFIG_DEPENDABOT}"

            if git diff --exit-code --quiet "${CONFIG_DEPENDABOT}"; then
              echo "No changes detected."
            else
              echo "Update branch name for LTS(New value: ${NEW_LTS_BRANCH})."
              git diff "${CONFIG_DEPENDABOT}"
              
              echo '::group::Committing changes'
              git add "${CONFIG_DEPENDABOT}"
              git commit -F-<<EOF
            chore: update dependabot.yml

            Update branch name for LTS (new value: ${NEW_LTS_BRANCH})
            [skip ci]
            EOF
              git show
              echo '::endgroup::'
            fi
            echo '::endgroup::'
          fi

      - name: 📁 Archive old maintenance branch
        shell: bash
        env:
          NEW_LTS_BRANCH: ${{ inputs.next_lts_branch }}
        run: |
          if [[ "${{ inputs.dry_run }}" == "true" ]]; then
            if [[ "${{ contains(inputs.release_version, 'major') && !contains(inputs.release_version, 'pre') }}" == "true" ]]; then
              echo "DRY RUN: Would archive old maintenance branch"
              # Calculate the old maintenance branch (two versions back)
              NEW_LTS_VERSION=$(echo ${NEW_LTS_BRANCH} | grep -o -E "([0-9]+){1}" | head -n1)
              OLD_LTS_VERSION=$((NEW_LTS_VERSION - 1))
              OLD_LTS_BRANCH="v${OLD_LTS_VERSION}"
              echo "DRY RUN: Would archive ${OLD_LTS_BRANCH} branch"
            else
              echo "DRY RUN: Not a major release, would skip archiving old maintenance branch"
            fi
          else
            if [[ "${{ contains(inputs.release_version, 'major') && !contains(inputs.release_version, 'pre') }}" == "true" ]]; then
              echo "::group::Archiving old maintenance branch"

              # Calculate the old maintenance branch (two versions back)
              # Extract the version number from the new LTS branch (e.g., v8 -> 8)
              NEW_LTS_VERSION=$(echo ${NEW_LTS_BRANCH} | grep -o -E "([0-9]+){1}" | head -n1)

              # Calculate the old LTS version (two versions back from current)
              OLD_LTS_VERSION=$((NEW_LTS_VERSION - 1))
              OLD_LTS_BRANCH="v${OLD_LTS_VERSION}"

              echo "New LTS branch: ${NEW_LTS_BRANCH} (version ${NEW_LTS_VERSION})"
              echo "Old LTS branch to archive: ${OLD_LTS_BRANCH} (version ${OLD_LTS_VERSION})"

              # Check if the old branch exists
              if git ls-remote --heads origin ${OLD_LTS_BRANCH} | grep -q ${OLD_LTS_BRANCH}; then
                echo "Old maintenance branch ${OLD_LTS_BRANCH} exists, preparing to archive it"

                # Fetch the old branch
                git fetch origin ${OLD_LTS_BRANCH}

                # Create a local copy of the branch
                git checkout -b archive-temp origin/${OLD_LTS_BRANCH}

                # Use the TypeScript script to update documentation for archiving
                pnpx tsx scripts/update-maintenance-docs.ts archive ${NEW_LTS_BRANCH} ${OLD_LTS_BRANCH}

                # Commit and push the change
                git add ARCHIVED.md README.md
                git commit -m "docs: mark branch as archived in README.md and ARCHIVED.md [skip ci]"
                git push origin archive-temp:${OLD_LTS_BRANCH}

                echo "✅ Successfully archived ${OLD_LTS_BRANCH}"

                # Return to the original branch
                git checkout ${{ inputs.target_branch }}
                git branch -D archive-temp
              else
                echo "Old maintenance branch ${OLD_LTS_BRANCH} does not exist, skipping archival"
              fi

              echo "::endgroup::"
            else
              echo "Not a major release, skipping archiving old maintenance branch"
            fi
          fi

      - name: 🌱 Create new feature branch for next major version
        shell: bash
        run: |
          if [[ "${{ inputs.dry_run }}" == "true" ]]; then
            if [[ "${{ contains(inputs.release_version, 'major') && !contains(inputs.release_version, 'pre') && inputs.branch_type == 'feature' }}" == "true" ]]; then
              # Calculate the next major version
              CURRENT_VERSION=$(jq -r '.version' packages/wdio-electron-service/package.json)
              CURRENT_MAJOR=$(echo $CURRENT_VERSION | cut -d. -f1)
              NEXT_MAJOR=$((CURRENT_MAJOR + 1))
              FEATURE_BRANCH="feature/v${NEXT_MAJOR}"
              echo "DRY RUN: Would create new feature branch ${FEATURE_BRANCH} for next major version"
            else
              echo "DRY RUN: Not a major release from feature branch, would skip creating new feature branch"
            fi
          else
            if [[ "${{ contains(inputs.release_version, 'major') && !contains(inputs.release_version, 'pre') && inputs.branch_type == 'feature' }}" == "true" ]]; then
              echo "::group::Creating feature branch for next major version"

              # Calculate the next major version
              CURRENT_VERSION=$(jq -r '.version' packages/wdio-electron-service/package.json)
              CURRENT_MAJOR=$(echo $CURRENT_VERSION | cut -d. -f1)
              NEXT_MAJOR=$((CURRENT_MAJOR + 1))
              FEATURE_BRANCH="feature/v${NEXT_MAJOR}"

              # Check if branch already exists remotely
              if git ls-remote --heads origin ${FEATURE_BRANCH} | grep -q ${FEATURE_BRANCH}; then
                echo "The feature branch ${FEATURE_BRANCH} already exists remotely."
                exit 0
              fi

              # Check if branch exists locally
              if git rev-parse --verify --quiet "${FEATURE_BRANCH}" >/dev/null; then
                echo "The feature branch ${FEATURE_BRANCH} already exists locally."
              else
                echo "Creating the feature branch ${FEATURE_BRANCH}..."

                # Create the branch from main
                git checkout main
                git pull origin main
                git branch ${FEATURE_BRANCH}
                git checkout ${FEATURE_BRANCH}

                git commit --allow-empty -m "chore: initialize feature branch for v${NEXT_MAJOR} [skip ci]"
                echo "Initialized feature branch with empty commit"

                # Return to the original branch
                git checkout ${{ inputs.target_branch }}
              fi

              echo "✅ Feature branch ${FEATURE_BRANCH} is ready"
              echo "::endgroup::"
            else
              echo "Not a major release from feature branch, skipping creating new feature branch"
            fi
          fi


      - name: 🚀 Push All Tags & Branches
        id: push_tags
        shell: bash
        env:
          NEW_LTS_BRANCH: ${{ inputs.next_lts_branch }}
        run: |
          if [[ "${{ inputs.dry_run }}" == "true" ]]; then
            echo "DRY RUN: Would push tags and all branches"

            # Calculate the next major version for feature branch
            CURRENT_VERSION=$(jq -r '.version' packages/wdio-electron-service/package.json)
            CURRENT_MAJOR=$(echo $CURRENT_VERSION | cut -d. -f1)
            NEXT_MAJOR=$((CURRENT_MAJOR + 1))
            FEATURE_BRANCH="feature/v${NEXT_MAJOR}"

            echo "DRY RUN: Would push the following if they exist:"
            echo "  - Tags (including release tag)"
            echo "  - Current branch commits"
            echo "  - ${NEW_LTS_BRANCH} (LTS/maintenance branch)"
            echo "  - ${FEATURE_BRANCH} (next feature branch)"
            echo "  - main (if merged from feature branch)"
          else
            echo "::group::Pushing tags and all branches"
            echo "Git log:"
            git log --oneline -n 5

            # Get the most recent tag (the one we just created)
            RELEASE_TAG=$(git describe --tags $(git rev-list --tags --max-count=1))
            echo "Release tag: $RELEASE_TAG"

            echo "Pushing tags and commits..."
            # Push tags and commits (including any dependabot config changes) without running the pre-push hook
            git push --tags --no-verify && git push --no-verify

            # Pass the release tag to the next step
            echo "RELEASE_TAG=$RELEASE_TAG" >> $GITHUB_OUTPUT

            # Push the LTS/maintenance branch if it exists locally
            if git rev-parse --verify --quiet "${NEW_LTS_BRANCH}" >/dev/null; then
              echo "Pushing the LTS/maintenance branch: ${NEW_LTS_BRANCH}..."
              git push --no-verify --set-upstream origin "${NEW_LTS_BRANCH}"
              echo "✅ Successfully pushed LTS branch ${NEW_LTS_BRANCH}"
            fi

            # Calculate the next major version for feature branch
            CURRENT_VERSION=$(jq -r '.version' packages/wdio-electron-service/package.json)
            CURRENT_MAJOR=$(echo $CURRENT_VERSION | cut -d. -f1)
            NEXT_MAJOR=$((CURRENT_MAJOR + 1))
            FEATURE_BRANCH="feature/v${NEXT_MAJOR}"

            # Push the next feature branch if it exists locally
            if git rev-parse --verify --quiet "${FEATURE_BRANCH}" >/dev/null; then
              echo "Pushing the next feature branch: ${FEATURE_BRANCH}..."
              git push --no-verify --set-upstream origin "${FEATURE_BRANCH}"
              echo "✅ Successfully pushed feature branch ${FEATURE_BRANCH}"
            fi

            # Push the merged main branch if it exists
            if [[ "${MERGE_SUCCESSFUL}" == "true" ]] && git rev-parse --verify --quiet "temp-main-for-merge" >/dev/null; then
              echo "Pushing merged main branch..."
              git checkout temp-main-for-merge
              git push --no-verify --force-with-lease origin temp-main-for-merge:main
              echo "✅ Successfully pushed merged main branch"

              # Return to the original branch
              git checkout ${{ inputs.target_branch }}
            fi

            echo "::endgroup::"
          fi

      # Create appropriate milestones based on the release type
      - name: 🏷️ Create GitHub Milestones
        # Skip during dry runs and prereleases
        if: ${{ !inputs.dry_run && !contains(inputs.release_version, 'pre') }}
        env:
          GITHUB_TOKEN: ${{ secrets.github_bot_token }}
          RELEASE_TYPE: ${{ inputs.release_version }}
        run: |
          echo "::group::Creating GitHub milestones"
          pnpx tsx scripts/create-milestones.ts
          echo "::endgroup::"

      # Prepare for updating labels from release:future to release:next
      - name: 🔄 Prepare Release Label Updates
        # Skip during dry runs and prereleases
        run: |
          if [[ "${{ inputs.dry_run }}" == "true" ]]; then
            if [[ "${{ !contains(inputs.release_version, 'pre') }}" == "true" ]]; then
              echo "DRY RUN: Would prepare release label updates"
              echo "DRY RUN: Would suggest running: GITHUB_TOKEN=<your-token> TRACK=${{ inputs.branch_type }} pnpx tsx scripts/update-release-labels.ts"
            else
              echo "DRY RUN: Pre-release, would skip label updates"
            fi
          else
            if [[ "${{ !contains(inputs.release_version, 'pre') }}" == "true" ]]; then
              echo "::group::Preparing release label updates"
              echo "After the release is complete, you should manually run the label update script:"
              echo ""
              echo "  GITHUB_TOKEN=<your-token> TRACK=${{ inputs.branch_type }} pnpx tsx scripts/update-release-labels.ts"
              echo ""
              echo "To create a GitHub token:"
              echo "1. Go to https://github.com/settings/tokens"
              echo "2. Click 'Generate new token' > 'Generate new token (classic)'"
              echo "3. Give it a name like 'Label Update Script'"
              echo "4. Select the 'repo' scope (to manage repository labels)"
              echo "5. Click 'Generate token' and copy the token"
              echo ""
              echo "This will help you review and update issues/PRs from 'release:future' to 'release:next'"
              echo "::endgroup::"
            else
              echo "Pre-release, skipping label updates"
            fi
          fi
