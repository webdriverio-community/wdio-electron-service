name: E2E Tests
description: 'Runs end-to-end tests across different scenarios and JavaScript module types'

on:
  workflow_call:
    # Make this a reusable workflow, no value needed
    # https://docs.github.com/en/actions/using-workflows/reusing-workflows
    inputs:
      os:
        description: 'Operating system to run tests on'
        required: true
        type: string
      node-version:
        description: 'Node.js version to use for testing'
        required: true
        type: string
      build-command:
        description: 'Build command for test applications (build or build:mac-universal)'
        type: string
        default: 'build'
      scenario:
        description: 'Test scenario (forge, builder, or no-binary)'
        required: true
        type: string
      type:
        description: 'JavaScript module type (esm, cjs, or * for both)'
        type: string
        default: '*'
      build_id:
        description: 'Build ID from the build job'
        type: string
        required: false
      artifact_size:
        description: 'Size of the build artifact in bytes'
        type: string
        required: false
      cache_key:
        description: 'Cache key to use for downloading artifacts'
        type: string
        required: false

env:
  TURBO_TELEMETRY_DISABLED: 1

jobs:
  # This job runs E2E tests for a specific combination of:
  # - Operating system (Linux, Windows, macOS)
  # - Test scenario (builder, forge, no-binary)
  # - Module type (ESM, CJS, or both)
  e2e:
    name: E2E Tests
    runs-on: ${{ inputs.os }}
    continue-on-error: true
    strategy:
      # Continue with other tests even if one fails
      fail-fast: false
    steps:
      # Standard checkout with SSH key for private repositories
      - name: ðŸ‘· Checkout Repository
        uses: actions/checkout@v4
        with:
          ssh-key: ${{ secrets.DEPLOY_KEY }}

      # Set up Node.js and PNPM using the reusable action
      - name: ðŸ› ï¸ Setup Development Environment
        uses: ./.github/workflows/actions/setup-workspace
        with:
          node-version: ${{ inputs.node-version }}

      # Download the pre-built packages from the build job
      # This ensures all tests use the same build artifacts
      - name: ðŸ“¦ Download Build Artifacts
        uses: ./.github/workflows/actions/download-archive
        with:
          name: wdio-electron-service
          path: wdio-electron-service-build
          filename: artifact.zip
          cache_key_prefix: wdio-electron-build
          exact_cache_key: ${{ inputs.cache_key || github.run_id && format('{0}-{1}-{2}-{3}{4}', 'Linux', 'wdio-electron-build', 'wdio-electron-service', github.run_id, github.run_attempt > 1 && format('-rerun{0}', github.run_attempt) || '') || '' }}

      # Verify the downloaded build artifacts
      - name: ðŸ” Verify Downloaded Artifacts
        shell: bash
        run: |
          echo "=============== VERIFYING BUILD ARTIFACTS ==============="
          echo "Artifact directory contents:"
          ls -la wdio-electron-service-build

          # Check if packaged-service exists
          if [ -d "wdio-electron-service-build/packaged-service" ]; then
            echo "âœ… Found packaged-service directory"
            echo "Contents of packaged-service directory:"
            ls -la wdio-electron-service-build/packaged-service
          else
            echo "âŒ packaged-service directory not found"
            echo "Creating packaged-service directory for debugging:"
            mkdir -p wdio-electron-service-build/packaged-service
          fi

          # Check for dist directories
          if [ -d "wdio-electron-service-build/packages" ]; then
            echo "âœ… Found packages directory"
            echo "Contents of packages directory:"
            ls -la wdio-electron-service-build/packages
          else
            echo "âŒ packages directory not found"
          fi

      # Package service locally if not found in build artifacts
      - name: ðŸ“¦ Create Service Package Locally
        shell: bash
        id: local-package-service
        if: ${{ success() }}
        run: |
          # Check if packaged-service directory exists and has a .tgz file
          if [ -d "wdio-electron-service-build/packaged-service" ]; then
            SERVICE_PACKAGE=$(find wdio-electron-service-build/packaged-service -name "wdio-electron-service-*.tgz" 2>/dev/null | head -n 1)
            if [ -n "$SERVICE_PACKAGE" ]; then
              echo "âœ… Using service package from build artifacts: $SERVICE_PACKAGE"
              echo "WDIO_SERVICE_TARBALL=$(pwd)/$SERVICE_PACKAGE" >> $GITHUB_ENV
              echo "USE_ARTIFACT_SERVICE=true" >> $GITHUB_ENV
              echo "SKIP_SERVICE_PACKING=true" >> $GITHUB_ENV

              echo "Installing service package in example apps..."
              # Get the active scenario and module type
              IFS=',' read -ra SCENARIOS <<< "${{ inputs.scenario }}"
              MODULE_TYPE="${{ inputs.type }}"

              for SCENARIO in "${SCENARIOS[@]}"; do
                TRIMMED_SCENARIO=$(echo $SCENARIO | xargs)

                if [[ "$MODULE_TYPE" == "*" ]]; then
                  # Both ESM and CJS need to be installed
                  APP_DIRS=("apps/${TRIMMED_SCENARIO}-esm" "apps/${TRIMMED_SCENARIO}-cjs")
                else
                  # Only install for the specific module type
                  APP_DIRS=("apps/${TRIMMED_SCENARIO}-${MODULE_TYPE}")
                fi

                for APP_DIR in "${APP_DIRS[@]}"; do
                  if [ -d "$APP_DIR" ]; then
                    echo "Installing service package in $APP_DIR..."
                    cd "$APP_DIR"
                    pnpm install "$(pwd)/../../$SERVICE_PACKAGE" --no-lockfile
                    cd ../..
                  else
                    echo "Skipping non-existent app directory: $APP_DIR"
                  fi
                done
              done

              exit 0
            fi
          fi

          echo "âŒ Service package not found in build artifacts. Creating locally..."

          # Create a local package
          mkdir -p local-service-package
          cd packages/wdio-electron-service
          echo "Running pnpm pack in $(pwd)"
          PACKAGE_FILE=$(pnpm pack | tail -n 1)

          if [ -f "$PACKAGE_FILE" ]; then
            echo "âœ… Successfully created package: $PACKAGE_FILE"
            # Move the package to the shared directory
            mv "$PACKAGE_FILE" ../../local-service-package/
            cd ../..
            echo "WDIO_SERVICE_TARBALL=$(pwd)/local-service-package/$PACKAGE_FILE" >> $GITHUB_ENV
            echo "USE_ARTIFACT_SERVICE=true" >> $GITHUB_ENV
            echo "SKIP_SERVICE_PACKING=true" >> $GITHUB_ENV
            echo "Local service package created at: $(pwd)/local-service-package/$PACKAGE_FILE"
            ls -la local-service-package
          else
            echo "âŒ Failed to create local service package"
            cd ../..
            echo "USE_ARTIFACT_SERVICE=false" >> $GITHUB_ENV
            echo "SKIP_SERVICE_PACKING=false" >> $GITHUB_ENV
          fi

      # Display build information if available
      - name: ðŸ“Š Show Build Information
        if: inputs.build_id != '' && inputs.artifact_size != ''
        shell: bash
        run: |
          echo "::notice::Build artifact: ID=${{ inputs.build_id }}, Size=${{ inputs.artifact_size }} bytes"

      # Special workaround for Linux to enable Electron testing
      - name: ðŸ”§ Apply Linux Kernel Workaround
        # https://github.com/electron/electron/issues/41066
        if: ${{ runner.os == 'Linux' }}
        shell: bash
        run: sudo sysctl -q -w kernel.apparmor_restrict_unprivileged_userns=0

      # Prepare the test applications once - new approach
      - name: ðŸ—ï¸ Prepare Test Applications
        shell: bash
        env:
          # Increase Node.js memory limit to prevent OOM issues
          NODE_OPTIONS: '--max-old-space-size=8192'
          # Preserve temp directories between steps
          PRESERVE_TEMP_DIR: 'true'
          # Enable more detailed debug logging
          DEBUG: 'wdio-electron-service*'
          # Use the pre-built service from the build job
          USE_ARTIFACT_SERVICE: 'true'
        timeout-minutes: 15
        run: |
          # Show diagnostic information
          echo "=============== ENVIRONMENT INFO ==============="
          echo "OS: ${{ runner.os }}"
          echo "Node.js version: $(node --version)"
          echo "NPM version: $(npm --version)"
          echo "PNPM version: $(pnpm --version)"
          echo "Current directory: $(pwd)"
          echo "Available disk space: $(df -h .)"
          echo "Available memory: $(free -h || echo 'free command not available')"
          echo "NODE_OPTIONS=$NODE_OPTIONS"

          # Debug electron-bundler package
          echo "=============== BUNDLER PACKAGE DIAGNOSTICS ==============="
          echo "Checking for @wdio/electron-bundler module..."
          BUNDLER_PATH=$(find packages -name "electron-bundler" -type d | grep -v "node_modules" || echo "Not found")
          if [ "$BUNDLER_PATH" != "Not found" ]; then
            echo "âœ… electron-bundler found at: $BUNDLER_PATH"
            cat $BUNDLER_PATH/package.json | grep -E "name|version"

            # Check dependencies
            echo "Checking bundler dependencies:"
            if [ -f "$BUNDLER_PATH/package.json" ]; then
              cat $BUNDLER_PATH/package.json | grep -A 15 "dependencies"
              cat $BUNDLER_PATH/package.json | grep -A 15 "devDependencies"
            fi

            # Check if it's built
            if [ -d "$BUNDLER_PATH/dist" ]; then
              echo "âœ… dist directory exists"
              ls -la $BUNDLER_PATH/dist
            else
              echo "âŒ dist directory missing"
            fi
          else
            echo "âŒ electron-bundler not found"
            echo "Looking in workspace packages.json..."
            cat package.json | grep -A 10 "workspaces"
          fi

          # Check workspace build status
          echo "Checking if workspace packages are already built:"
          find packages -name "dist" -type d | grep -v "node_modules" || echo "No dist directories found"

          # Build dependencies first
          echo "=============== BUILDING WORKSPACE DEPENDENCIES ==============="
          echo "Building all workspace packages..."
          pnpm run build

          # For MacOS, verify workspace dependencies are built
          if [[ "${{ runner.os }}" == "macOS" ]]; then
            echo "Checking workspace module directories:"

            echo "Looking for @wdio/electron-bundler dist directory..."
            if ls packages/**/electron-bundler/dist 2>/dev/null; then
              echo "âœ… electron-bundler dist directory found"
            else
              echo "âŒ electron-bundler dist directory not found"
              echo "Attempting to build it specifically..."
              if [ -d "packages/@wdio/electron-bundler" ]; then
                cd packages/@wdio/electron-bundler
                pnpm install
                pnpm build
                cd ../..
              else
                find packages -name "electron-bundler" -type d | grep -v "node_modules" | while read dir; do
                  echo "Found directory: $dir, attempting to build..."
                  cd "$dir"
                  pnpm install
                  pnpm build
                  cd - > /dev/null
                done
              fi
            fi
          fi

          # Show process resource limits
          echo "=============== RESOURCE LIMITS ==============="
          ulimit -a || echo "ulimit command not available"

          # Increase available resources
          if [[ "${{ runner.os }}" == "Linux" ]]; then
            echo "Increasing system limits for Linux"
            ulimit -n 65536 || echo "Failed to increase ulimit"
            ulimit -u 65536 || echo "Failed to increase process limit"
            echo "Updated limits:"
            ulimit -a || echo "ulimit command not available"
          fi

          # Show running processes
          echo "=============== RUNNING PROCESSES ==============="
          ps aux | grep -E 'node|electron' || echo "No node/electron processes found"

          # Generate build filters based on scenarios
          BUILD_FILTERS=""
          FORGE_FILTERS=""
          NON_FORGE_FILTERS=""
          IS_FORGE=$([[ "${{ inputs.scenario }}" == *"forge"* ]] && echo "true" || echo "false")
          IS_WINDOWS_FORGE=$([[ "${{ runner.os }}" == "Windows" && "$IS_FORGE" == "true" ]] && echo "true" || echo "false")
          IS_LINUX_FORGE=$([[ "${{ runner.os }}" == "Linux" && "$IS_FORGE" == "true" ]] && echo "true" || echo "false")

          echo "Is Forge: $IS_FORGE"
          echo "Is Windows Forge: $IS_WINDOWS_FORGE"
          echo "Is Linux Forge: $IS_LINUX_FORGE"

          # Debug environment
          if [[ "${{ runner.os }}" == "Windows" || "${{ runner.os }}" == "Linux" ]]; then
            echo "Environment debugging for ${{ runner.os }}"
            echo "Node.js version: $(node --version)"
            echo "NPM version: $(npm --version)"
            echo "PNPM version: $(pnpm --version)"
            echo "Current directory: $(pwd)"
            echo "Testing directory creation..."
            mkdir -p test-dir && echo "SUCCESS" || echo "FAILURE"
            node -e "require('fs').mkdirSync('test-dir2', { recursive: true }); console.log('SUCCESS');" || echo "FAILURE"
          fi

          IFS=',' read -ra SCENARIOS <<< "${{ inputs.scenario }}"
          for SCENARIO in "${SCENARIOS[@]}"; do
            TRIMMED_SCENARIO=$(echo $SCENARIO | xargs)

            if [[ "$IS_WINDOWS_FORGE" == "true" || "$IS_LINUX_FORGE" == "true" ]] && [[ "$TRIMMED_SCENARIO" == "forge" ]]; then
              # For Windows/Linux forge builds, we'll handle them separately
              FORGE_FILTERS="$FORGE_FILTERS --filter=example-${TRIMMED_SCENARIO}-*"
            else
              # For all other builds, we'll run them in parallel
              NON_FORGE_FILTERS="$NON_FORGE_FILTERS --filter=example-${TRIMMED_SCENARIO}-*"
            fi
          done

          # Build non-forge apps in parallel (if any)
          if [[ -n "$NON_FORGE_FILTERS" ]]; then
            echo "Building non-forge apps with filters: $NON_FORGE_FILTERS"
            pnpm exec turbo run ${{ inputs.build-command }} $NON_FORGE_FILTERS --only --parallel
          fi

          # Build forge apps with special handling on Windows and Linux
          if [[ "$IS_WINDOWS_FORGE" == "true" || "$IS_LINUX_FORGE" == "true" ]] && [[ -n "$FORGE_FILTERS" ]]; then
            echo "Building Forge apps sequentially on ${{ runner.os }} with filters: $FORGE_FILTERS"

            # First clean the forge output directories to prevent dest already exists errors
            echo "Cleaning Electron Forge output directories..."
            for appDir in forge-cjs forge-esm; do
              echo "Cleaning output for $appDir"
              # Remove the out directory where Electron Forge places packaged apps
              rm -rf "apps/$appDir/out" || true
              # Also ensure dist is clean
              rm -rf "apps/$appDir/dist" || true

              # Create clean directories using node instead of bash commands for better cross-platform compatibility
              node -e "const fs = require('fs'); fs.mkdirSync('apps/$appDir/dist', { recursive: true });"

              echo "Cleaned $appDir directories"
            done

            # Use modified approach to build forge apps with explicit environment variables
            echo "Using custom approach for Forge builds on ${{ runner.os }}"
            for appDir in forge-cjs forge-esm; do
              echo "Building $appDir with custom approach..."

              # Go to the app directory
              cd "apps/$appDir"

              # Compile the TypeScript first
              pnpm exec tsc

              # Bundle with Rollup
              if [[ "$appDir" == "forge-cjs" ]]; then
                pnpm exec rollup -c rollup.config.mjs
              else
                pnpm exec rollup -c rollup.config.js
              fi

              # Copy HTML files
              cp ./src/*.html ./dist/

              # Package with Electron Forge using the pre-downloaded binary
              echo "Packaging $appDir with Electron Forge..."

              # Run electron-forge package with environment variables
              ELECTRON_CACHE="$GITHUB_WORKSPACE/electron-cache" pnpm exec electron-forge package

              # Return to workspace root
              cd "$GITHUB_WORKSPACE"

              echo "Built $appDir successfully"
            done
          elif [[ -n "$FORGE_FILTERS" ]]; then
            # For other platforms, build forge apps in parallel
            echo "Building forge apps with filters: $FORGE_FILTERS"
            pnpm exec turbo run ${{ inputs.build-command }} $FORGE_FILTERS --only --parallel
          fi

          # Then prepare the test apps for all tests
          echo "=============== RUNNING PREPARE-APPS ==============="
          echo "Running prepare-apps with increased timeout..."

          # Show current time for timing purposes
          echo "Start time: $(date)"

          # Run prepare-apps with detailed logging and environment variables
          cd e2e && NODE_OPTIONS="--max-old-space-size=8192" PRESERVE_TEMP_DIR=true \
            DEBUG=wdio-electron-service* \
            USE_ARTIFACT_SERVICE=$USE_ARTIFACT_SERVICE \
            WDIO_SERVICE_TARBALL="$WDIO_SERVICE_TARBALL" \
            SKIP_SERVICE_PACKING=$SKIP_SERVICE_PACKING \
            npx tsx scripts/prepare-apps.ts --timeout=300000

          # Show end time
          echo "End time: $(date)"
          echo "=============== PREPARE-APPS COMPLETED ==============="

          # Capture the test apps directory for later steps
          if [ -n "$WDIO_TEST_APPS_DIR" ]; then
            echo "WDIO_TEST_APPS_DIR=$WDIO_TEST_APPS_DIR" >> $GITHUB_ENV
            echo "WDIO_TEST_APPS_PREPARED=true" >> $GITHUB_ENV
            echo "PRESERVE_TEMP_DIR=true" >> $GITHUB_ENV
            echo "SUITE_SETUP_DONE=true" >> $GITHUB_ENV
            echo "Test apps prepared at: $WDIO_TEST_APPS_DIR"

            # List what's in the test apps directory
            echo "Test apps directory contents:"
            ls -la "$WDIO_TEST_APPS_DIR" || echo "Failed to list contents"

            # Check if apps directory exists and show contents
            if [ -d "$WDIO_TEST_APPS_DIR/apps" ]; then
              echo "Apps directory contents:"
              ls -la "$WDIO_TEST_APPS_DIR/apps" || echo "Failed to list apps contents"
            fi
          else
            echo "WARNING: WDIO_TEST_APPS_DIR not set after prepare-apps completed"
          fi

          # Show final diagnostic information
          echo "=============== FINAL ENVIRONMENT INFO ==============="
          echo "Available disk space: $(df -h .)"
          echo "Available memory: $(free -h || echo 'free command not available')"
          echo "Running processes:"
          ps aux | grep -E 'node|electron' || echo "No node/electron processes found"

      # Run tests based on the scenario and type inputs
      - name: ðŸ§ª Execute E2E Tests
        shell: bash
        id: run_tests
        env:
          # Set environment variables for testing
          PRESERVE_TEMP_DIR: 'true'
          # Pass through test apps variables from previous steps
          WDIO_TEST_APPS_PREPARED: ${{ env.WDIO_TEST_APPS_PREPARED }}
          WDIO_TEST_APPS_DIR: ${{ env.WDIO_TEST_APPS_DIR }}
          SUITE_SETUP_DONE: 'true'
          # Set MAC_UNIVERSAL flag if we're using the mac-universal build command
          MAC_UNIVERSAL: ${{ contains(inputs.build-command, 'mac-universal') && 'true' || '' }}
          # Add DEBUG for more verbose output
          DEBUG: 'wdio-electron-service*'
        run: |
          cd e2e

          # Log environment for debugging
          echo "Environment: MAC_UNIVERSAL=$MAC_UNIVERSAL, build-command=${{ inputs.build-command }}, ELECTRON_CACHE=$ELECTRON_CACHE"
          echo "Test apps: WDIO_TEST_APPS_PREPARED=$WDIO_TEST_APPS_PREPARED, WDIO_TEST_APPS_DIR=$WDIO_TEST_APPS_DIR, SUITE_SETUP_DONE=$SUITE_SETUP_DONE"

          # Generate test execution command based on the scenario and type
          if [[ "${{ inputs.scenario }}" == *","* ]]; then
            # Multiple scenarios
            IFS=',' read -ra SCENARIOS <<< "${{ inputs.scenario }}"

            for SCENARIO in "${SCENARIOS[@]}"; do
              TRIMMED_SCENARIO=$(echo $SCENARIO | xargs)

              if [[ "${{ inputs.type }}" == "*" ]]; then
                # Run both ESM and CJS tests
                pnpm run test:${TRIMMED_SCENARIO}:cjs
                pnpm run test:${TRIMMED_SCENARIO}:esm
              else
                # Run specific module type test
                pnpm run test:${TRIMMED_SCENARIO}:${{ inputs.type }}
              fi
            done
          else
            # Single scenario
            if [[ "${{ inputs.scenario }}" == "no-binary" ]]; then
              if [[ "${{ inputs.type }}" == "*" ]]; then
                # Run both ESM and CJS tests for no-binary
                pnpm run test:no-binary:cjs
                pnpm run test:no-binary:esm
              else
                # Run specific module type test for no-binary
                pnpm run test:no-binary:${{ inputs.type }}
              fi
            elif [[ "${{ inputs.scenario }}" == "builder" ]]; then
              if [[ "${{ inputs.type }}" == "*" ]]; then
                # Run both ESM and CJS tests for builder
                pnpm run test:builder:cjs
                pnpm run test:builder:esm
              else
                # Run specific module type test for builder
                pnpm run test:builder:${{ inputs.type }}
              fi
            elif [[ "${{ inputs.scenario }}" == "forge" ]]; then
              if [[ "${{ inputs.type }}" == "*" ]]; then
                # Run both ESM and CJS tests for forge
                pnpm run test:forge:cjs
                pnpm run test:forge:esm
              else
                # Run specific module type test for forge
                pnpm run test:forge:${{ inputs.type }}
              fi
            fi
          fi

      # Show logs on failure to help with debugging
      - name: ðŸ› Show Test Logs on Failure
        shell: bash
        if: failure()
        run: cd e2e && pnpm run cat-logs

      # Upload logs as artifacts on failure for later analysis
      # This helps debug issues without cluttering the GitHub Actions console
      - name: ðŸ“¦ Upload Test Logs on Failure
        uses: ./.github/workflows/actions/upload-archive
        if: failure()
        with:
          name: e2e-logs-${{ inputs.os }}${{ contains(inputs.build-command, 'mac-universal') && '-u' || '' }}-${{ inputs.scenario }}${{ inputs.type != '*' && format('-{0}',inputs.type) || '' }}
          output: e2e-logs-${{ inputs.os }}${{ contains(inputs.build-command, 'mac-universal') && '-u' || '' }}-${{ inputs.scenario }}${{ inputs.type != '*' && format('-{0}',inputs.type) || '' }}.zip
          paths: e2e/logs

      # Clean up temp directories after tests complete
      - name: ðŸ§¹ Clean Up Temporary Directories
        shell: bash
        if: always()
        run: cd e2e && pnpm run clean:temp-dirs

      # Provide an interactive debugging session on failure
      - name: ðŸ› Debug Build on Failure
        uses: stateful/vscode-server-action@v1.1.0
        if: failure()
        with:
          timeout: '180000'
