name: E2E Tests
description: 'Runs end-to-end tests across different scenarios and JavaScript module types'

on:
  workflow_call:
    # Make this a reusable workflow, no value needed
    # https://docs.github.com/en/actions/using-workflows/reusing-workflows
    inputs:
      os:
        description: 'Operating system to run tests on'
        required: true
        type: string
      node-version:
        description: 'Node.js version to use for testing'
        required: true
        type: string
      build-command:
        description: 'Build command for test applications (build or build:mac-universal)'
        type: string
        default: 'build'
      scenario:
        description: 'Test scenario (forge, builder, or no-binary)'
        required: true
        type: string
      type:
        description: 'JavaScript module type (esm, cjs, or * for both)'
        type: string
        default: '*'
      build_id:
        description: 'Build ID from the build job'
        type: string
        required: false
      artifact_size:
        description: 'Size of the build artifact in bytes'
        type: string
        required: false
      cache_key:
        description: 'Cache key to use for downloading artifacts'
        type: string
        required: false

env:
  TURBO_TELEMETRY_DISABLED: 1

jobs:
  # This job runs E2E tests for a specific combination of:
  # - Operating system (Linux, Windows, macOS)
  # - Test scenario (builder, forge, no-binary)
  # - Module type (ESM, CJS, or both)
  e2e:
    name: E2E Tests
    runs-on: ${{ inputs.os }}
    continue-on-error: true
    strategy:
      # Continue with other tests even if one fails
      fail-fast: false
    steps:
      # Standard checkout with SSH key for private repositories
      - name: üë∑ Checkout Repository
        uses: actions/checkout@v4
        with:
          ssh-key: ${{ secrets.DEPLOY_KEY }}

      # Set up Node.js and PNPM using the reusable action
      - name: üõ†Ô∏è Setup Development Environment
        uses: ./.github/workflows/actions/setup-workspace
        with:
          node-version: ${{ inputs.node-version }}

      # Download the pre-built packages from the build job
      # This ensures all tests use the same build artifacts
      - name: üì¶ Download Build Artifacts
        uses: ./.github/workflows/actions/download-archive
        with:
          name: wdio-electron-service
          path: wdio-electron-service-build
          filename: artifact.zip
          cache_key_prefix: wdio-electron-build
          exact_cache_key: ${{ inputs.cache_key || github.run_id && format('{0}-{1}-{2}-{3}{4}', 'Linux', 'wdio-electron-build', 'wdio-electron-service', github.run_id, github.run_attempt > 1 && format('-rerun{0}', github.run_attempt) || '') || '' }}

      # Verify the downloaded build artifacts
      - name: üîç Verify Downloaded Artifacts
        shell: bash
        run: |
          echo "=============== VERIFYING BUILD ARTIFACTS ==============="
          echo "Artifact directory contents:"
          ls -la wdio-electron-service-build

          # Check if packaged-service exists
          if [ -d "wdio-electron-service-build/packaged-service" ]; then
            echo "‚úÖ Found packaged-service directory"
            echo "Contents of packaged-service directory:"
            ls -la wdio-electron-service-build/packaged-service
          else
            echo "‚ùå packaged-service directory not found"
            echo "Creating packaged-service directory for debugging:"
            pnpx shx mkdir -p wdio-electron-service-build/packaged-service
          fi

          # Check for dist directories
          if [ -d "wdio-electron-service-build/packages" ]; then
            echo "‚úÖ Found packages directory"
            echo "Contents of packages directory:"
            ls -la wdio-electron-service-build/packages
          else
            echo "‚ùå packages directory not found"
          fi

      # Copy the artifact package dist directory to the local package directory
      - name: üì¶ Copy Artifact Package Dist Directory
        shell: bash
        run: |
          # Dynamically find all package directories in the artifact build
          echo "Finding packages with dist directories in the artifact build..."
          find wdio-electron-service-build/packages -type d -name dist -path "*/packages/*" | while read dist_dir; do
            # Extract the package name by getting the parent directory name
            package_dir=$(dirname "$dist_dir")
            package_name=$(basename "$package_dir")
            package_path="packages/$package_name"

            if [ -d "$package_path" ]; then
              echo "Copying dist directory for $package_name..."
              pnpx shx mkdir -p "$package_path/dist"
              pnpx shx cp -r "$dist_dir"/* "$package_path/dist/"
              echo "‚úÖ Copied dist files for $package_name"
            else
              echo "‚ö†Ô∏è Local package directory not found: $package_path"
            fi
          done

      # Package service locally if not found in build artifacts
      - name: üì¶ Create Service Package Locally
        shell: bash
        id: local-package-service
        if: ${{ success() }}
        run: |
          # Check if packaged-service directory exists and has a .tgz file
          if [ -d "wdio-electron-service-build/packaged-service" ]; then
            SERVICE_PACKAGE=$(find wdio-electron-service-build/packaged-service -name "wdio-electron-service-*.tgz" 2>/dev/null | head -n 1)
            if [ -n "$SERVICE_PACKAGE" ]; then
              echo "‚úÖ Using service package from build artifacts: $SERVICE_PACKAGE"
              echo "WDIO_SERVICE_TARBALL=$(pwd)/$SERVICE_PACKAGE" >> $GITHUB_ENV
              echo "USE_ARTIFACT_SERVICE=true" >> $GITHUB_ENV
              echo "SKIP_SERVICE_PACKING=true" >> $GITHUB_ENV

              echo "Installing service package in example apps..."
              # Get the active scenario and module type
              IFS=',' read -ra SCENARIOS <<< "${{ inputs.scenario }}"
              MODULE_TYPE="${{ inputs.type }}"

              for SCENARIO in "${SCENARIOS[@]}"; do
                TRIMMED_SCENARIO=$(echo $SCENARIO | xargs)

                if [[ "$MODULE_TYPE" == "*" ]]; then
                  # Both ESM and CJS need to be installed
                  APP_DIRS=("apps/${TRIMMED_SCENARIO}-esm" "apps/${TRIMMED_SCENARIO}-cjs")
                else
                  # Only install for the specific module type
                  APP_DIRS=("apps/${TRIMMED_SCENARIO}-${MODULE_TYPE}")
                fi

                for APP_DIR in "${APP_DIRS[@]}"; do
                  if [ -d "$APP_DIR" ]; then
                    echo "Installing service package in $APP_DIR..."
                    cd "$APP_DIR"
                    # Only install the service package since root dependencies are already installed
                    pnpm install "$(pwd)/../../$SERVICE_PACKAGE" --no-lockfile
                    cd ../..
                  else
                    echo "Skipping non-existent app directory: $APP_DIR"
                  fi
                done
              done

              exit 0
            fi
          fi

          echo "‚ùå Service package not found in build artifacts. Creating locally..."

          # Create a local package
          pnpx shx mkdir -p local-service-package
          cd packages/wdio-electron-service
          echo "Running pnpm pack in $(pwd)"
          PACKAGE_FILE=$(pnpm pack | tail -n 1)

          if [ -f "$PACKAGE_FILE" ]; then
            echo "‚úÖ Successfully created package: $PACKAGE_FILE"
            # Move the package to the shared directory
            mv "$PACKAGE_FILE" ../../local-service-package/
            cd ../..
            echo "WDIO_SERVICE_TARBALL=$(pwd)/local-service-package/$PACKAGE_FILE" >> $GITHUB_ENV
            echo "USE_ARTIFACT_SERVICE=true" >> $GITHUB_ENV
            echo "SKIP_SERVICE_PACKING=true" >> $GITHUB_ENV
            echo "Local service package created at: $(pwd)/local-service-package/$PACKAGE_FILE"
            ls -la local-service-package
          else
            echo "‚ùå Failed to create local service package"
            cd ../..
            echo "USE_ARTIFACT_SERVICE=false" >> $GITHUB_ENV
            echo "SKIP_SERVICE_PACKING=false" >> $GITHUB_ENV
          fi

      # Display build information if available
      - name: üìä Show Build Information
        if: inputs.build_id != '' && inputs.artifact_size != ''
        shell: bash
        run: |
          echo "::notice::Build artifact: ID=${{ inputs.build_id }}, Size=${{ inputs.artifact_size }} bytes"

      # Special workaround for Linux to enable Electron testing
      - name: üîß Apply Linux Kernel Workaround
        # https://github.com/electron/electron/issues/41066
        if: ${{ runner.os == 'Linux' }}
        shell: bash
        run: sudo sysctl -q -w kernel.apparmor_restrict_unprivileged_userns=0

      # Prepare the test applications once - new approach
      - name: üèóÔ∏è Prepare Test Applications
        shell: bash
        id: prepare_apps
        env:
          # Preserve temp directories between steps
          PRESERVE_TEMP_DIR: 'true'
          # Enable more detailed debug logging
          DEBUG: 'wdio-electron-service*'
          # Use the pre-built service from the build job
          USE_ARTIFACT_SERVICE: ${{ env.USE_ARTIFACT_SERVICE || 'true' }}
          # Pass through service tarball path if available
          WDIO_SERVICE_TARBALL: ${{ env.WDIO_SERVICE_TARBALL || '' }}
          # Debug environment variable for SIGTERM debugging
          WDIO_DEBUG_SIGTERM: 'true'
          # Enable ESM mode support to fix __filename not defined error
          NODE_OPTIONS: '--no-warnings --experimental-specifier-resolution=node'
        timeout-minutes: 15
        run: |
          echo "Preparing test applications for scenario: ${{ inputs.scenario }}, module type: ${{ inputs.type }}"

          # Print system diagnostics
          echo "=== System Diagnostics ==="
          echo "Operating System: ${{ runner.os }}"
          echo "Kernel version: $(uname -a)"
          if [[ "${{ runner.os }}" == "Linux" ]]; then
            echo "Memory: $(free -h)"
            echo "Disk space: $(df -h)"
          fi
          echo "================="

          # Process environment information
          echo "=== Environment Variables ==="
          printenv | sort
          echo "================="

          # Set up signal tracing on Linux
          if [[ "${{ runner.os }}" == "Linux" ]]; then
            echo "Setting up signal tracing on Linux..."

            # Create a trap for SIGTERM to get stack trace
            trap_sigterm() {
              echo "************* CAUGHT SIGTERM in prepare-apps.sh wrapper *************"
              echo "Time: $(date)"
              echo "Current process: $$"

              # Print stack trace if possible
              if type -t caller > /dev/null; then
                echo "Stack trace:"
                local i=0
                while caller $i; do
                  ((i++))
                done
              fi

              # Show what processes might be sending signals
              echo "Running processes (sorted by memory usage):"
              ps aux --sort=-%mem | head -15

              # Print parent process tree to help identify the source of SIGTERM
              echo "Process tree:"
              pstree -p $$

              echo "************* END SIGTERM TRAP *************"

              # Exit with SIGTERM exit code
              exit 143
            }

            # Set up the trap
            trap 'trap_sigterm' TERM

            # Monitor for processes that might be causing issues
            (
              while true; do
                echo "[$(date)] Process monitor check..."
                ps aux --sort=-%mem | head -8
                sleep 10
              done
            ) > process_monitor.log &
            MONITOR_PID=$!

            # Make sure to kill the monitor when this script exits
            trap 'kill $MONITOR_PID 2>/dev/null' EXIT
          fi

          # Add process monitoring on Linux
          if [[ "${{ runner.os }}" == "Linux" ]]; then
            echo "Setting up Linux process monitoring..."

            # Check for stray processes
            echo "Checking for stray electron or node processes:"
            ps aux | grep -E 'electron|node' | grep -v grep || echo "No matching processes found"

            # Print all running processes to see what else might be competing for resources
            echo "=== All Running Processes ==="
            ps aux --sort=-%mem | head -20
            echo "================="

            # Clean up any leftover test directories
            echo "Cleaning up any leftover test directories..."
            find /tmp -maxdepth 1 -name "wdio-e2e-*" -type d -mmin +60 -exec rm -rf {} \; 2>/dev/null || true
          fi

          echo "Running prepare apps command..."

          cd e2e
          echo "Running in $(pwd)"

          # Create debug file to capture any errors
          DEBUG_LOG="/tmp/prepare-apps-debug.log"
          echo "Debug log will be written to $DEBUG_LOG"

          # We need a way to catch SIGTERM and print diagnostics even if it happens in child processes
          # Run the command with additional debug capabilities
          {
            # Run the command and capture start time
            echo "Starting prepare-apps at $(date)"
            START_TIME=$(date +%s)

            # Run the prepare-apps script directly
            echo "Command: node --no-warnings --import tsx ./scripts/prepare-apps.js --timeout=600000 --scenario=${{ inputs.scenario }} --module-type=${{ inputs.type }}"
            node --no-warnings --import tsx ./scripts/prepare-apps.js --timeout=600000 --scenario=${{ inputs.scenario }} --module-type=${{ inputs.type }}
            RC=$?

            # Capture end time and calculate duration
            END_TIME=$(date +%s)
            DURATION=$((END_TIME - START_TIME))

            echo "prepare-apps completed with exit code $RC after ${DURATION}s"
            echo "Exit code: $RC"
          } 2>&1 | tee -a $DEBUG_LOG

          echo "=== Process completed ==="

          # Check if the process was terminated by a signal
          if [ $RC -gt 128 ]; then
            SIGNAL=$((RC - 128))
            echo "Process appears to have been terminated by signal $SIGNAL"

            if [ $SIGNAL -eq 15 ]; then
              echo "Process was terminated by SIGTERM (signal 15)"

              # Show process information
              echo "Current processes:"
              ps aux --sort=-%mem | head -15
            fi
          fi

          # Print debug log if the process failed
          if [[ -f "$DEBUG_LOG" ]]; then
            echo "Contents of debug log:"
            cat "$DEBUG_LOG"
          fi

          # Additional diagnostics if process monitor log exists
          if [[ -f "process_monitor.log" ]]; then
            echo "Process monitor log contents:"
            cat process_monitor.log
          fi

          # Save the environment variables to GITHUB_ENV to make them available to next steps
          if [[ -n "${WDIO_TEST_APPS_PREPARED}" ]]; then
            echo "WDIO_TEST_APPS_PREPARED=${WDIO_TEST_APPS_PREPARED}" >> $GITHUB_ENV
            echo "Exported WDIO_TEST_APPS_PREPARED=${WDIO_TEST_APPS_PREPARED}"
          fi

          if [[ -n "${WDIO_TEST_APPS_DIR}" ]]; then
            echo "WDIO_TEST_APPS_DIR=${WDIO_TEST_APPS_DIR}" >> $GITHUB_ENV
            echo "Exported WDIO_TEST_APPS_DIR=${WDIO_TEST_APPS_DIR}"
          fi

          # Create symlinks for workspace dependencies
          echo "Creating symlinks for workspace dependencies..."
          if [ -d "../wdio-electron-service-build/packages" ]; then
            pnpx shx mkdir -p node_modules

            # Find all workspace packages in the artifact
            find "../wdio-electron-service-build/packages" -maxdepth 1 -type d | grep -v "^../wdio-electron-service-build/packages$" | while read package_dir; do
              package_name=$(basename "$package_dir")

              if [ -d "$package_dir/node_modules" ]; then
                echo "Exploring dependencies in $package_name..."

                # Create symlinks for non-scoped packages
                find "$package_dir/node_modules" -maxdepth 1 -type d | grep -v "^$package_dir/node_modules$" | grep -v "^$package_dir/node_modules/@" | while read dep_dir; do
                  dep_name=$(basename "$dep_dir")
                  if [ ! -d "node_modules/$dep_name" ]; then
                    echo "Creating symlink for: $dep_name"
                    ln -s "$dep_dir" "node_modules/$dep_name" || true
                  fi
                done

                # Create symlinks for scoped packages
                find "$package_dir/node_modules" -maxdepth 1 -type d -name "@*" | while read scope_dir; do
                  scope_name=$(basename "$scope_dir")
                  pnpx shx mkdir -p "node_modules/$scope_name"
                  find "$scope_dir" -maxdepth 1 -type d | grep -v "^$scope_dir$" | while read scoped_dep_dir; do
                    scoped_dep_name=$(basename "$scoped_dep_dir")
                    if [ ! -d "node_modules/${scope_name}/${scoped_dep_name}" ]; then
                      echo "Creating symlink for: ${scope_name}/${scoped_dep_name}"
                      ln -s "$scoped_dep_dir" "node_modules/${scope_name}/${scoped_dep_name}" || true
                    fi
                  done
                done
              fi
            done
          fi

      # Run tests based on the scenario and type inputs
      - name: üß™ Execute E2E Tests
        shell: bash
        id: run_tests
        env:
          # Set environment variables for testing
          PRESERVE_TEMP_DIR: 'true'
          # Set MAC_UNIVERSAL flag if we're using the mac-universal build command
          MAC_UNIVERSAL: ${{ contains(inputs.build-command, 'mac-universal') && 'true' || '' }}
          # Add DEBUG for more verbose output
          DEBUG: 'wdio-electron-service*'
          # Test configuration
          SUITE_SETUP_DONE: 'true'
        run: |
          cd e2e

          # Log environment for debugging
          echo "Environment: MAC_UNIVERSAL=$MAC_UNIVERSAL, build-command=${{ inputs.build-command }}, ELECTRON_CACHE=$ELECTRON_CACHE"
          echo "Test apps: WDIO_TEST_APPS_PREPARED=${WDIO_TEST_APPS_PREPARED:-''}, WDIO_TEST_APPS_DIR=${WDIO_TEST_APPS_DIR:-''}, SUITE_SETUP_DONE=$SUITE_SETUP_DONE"

          # Debug: Check tools availability
          echo "=== Debug: Available Tools ==="
          echo "Node.js version: $(node --version)"
          echo "pnpm version: $(pnpm --version)"
          echo "WebdriverIO CLI:"
          if command -v wdio &> /dev/null; then
            echo "wdio command is available"
            wdio --version
          else
            echo "wdio command is NOT available"
          fi

          echo "Checking local WebdriverIO installation:"
          ls -la node_modules/.bin | grep wdio || echo "wdio not found in node_modules/.bin"

          # Check package.json scripts
          echo "Available scripts in package.json:"
          cat package.json | grep "\"test:" | sed 's/^/  /'

          # Check if test:single script exists
          test -f ./scripts/run-single-test.ts && echo "run-single-test.ts exists" || echo "run-single-test.ts does not exist"
          test -f ./scripts/run-test-matrix.ts && echo "run-test-matrix.ts exists" || echo "run-test-matrix.ts does not exist"

          # Set environment variables for test execution
          export WDIO_TEST_APPS_PREPARED=${WDIO_TEST_APPS_PREPARED:-''}
          export WDIO_TEST_APPS_DIR=${WDIO_TEST_APPS_DIR:-''}
          export WDIO_VERBOSE=true

          # Generate test execution command based on the scenario and type
          if [[ "${{ inputs.scenario }}" == "*" ]]; then
            # Run all scenarios
            if [[ "${{ inputs.type }}" == "*" ]]; then
              # Run all module types for all scenarios
              echo "Running all scenarios with all module types..."
              pnpm run test:matrix
            else
              # Run specific module type for all scenarios
              echo "Running all scenarios with ${{ inputs.type }} module type..."
              pnpm run test:matrix
            fi
          else
            # Single scenario
            if [[ "${{ inputs.scenario }}" == "no-binary" ]]; then
              if [[ "${{ inputs.type }}" == "*" ]]; then
                # Run both ESM and CJS tests for no-binary
                echo "Running no-binary CJS tests..."
                pnpm run test:no-binary:cjs

                echo "Running no-binary ESM tests..."
                pnpm run test:no-binary:esm
              else
                # Run specific module type test for no-binary
                echo "Running no-binary ${{ inputs.type }} tests..."
                pnpm run test:no-binary:${{ inputs.type }}
              fi
            elif [[ "${{ inputs.scenario }}" == "builder" ]]; then
              if [[ "${{ inputs.type }}" == "*" ]]; then
                # Run both ESM and CJS tests for builder
                echo "Running builder CJS tests..."
                pnpm run test:builder:cjs

                echo "Running builder ESM tests..."
                pnpm run test:builder:esm
              else
                # Run specific module type test for builder
                echo "Running builder ${{ inputs.type }} tests..."
                pnpm run test:builder:${{ inputs.type }}
              fi
            elif [[ "${{ inputs.scenario }}" == "forge" ]]; then
              if [[ "${{ inputs.type }}" == "*" ]]; then
                # Run both ESM and CJS tests for forge
                echo "Running forge CJS tests..."
                pnpm run test:forge:cjs

                echo "Running forge ESM tests..."
                pnpm run test:forge:esm
              else
                # Run specific module type test for forge
                echo "Running forge ${{ inputs.type }} tests..."
                pnpm run test:forge:${{ inputs.type }}
              fi
            fi
          fi

      # Show logs on failure to help with debugging
      - name: üêõ Show Test Logs on Failure
        shell: bash
        if: failure()
        run: cd e2e && pnpm run cat-logs

      # Upload logs as artifacts on failure for later analysis
      # This helps debug issues without cluttering the GitHub Actions console
      - name: üì¶ Upload Test Logs on Failure
        uses: ./.github/workflows/actions/upload-archive
        if: failure()
        with:
          name: e2e-logs-${{ inputs.os }}${{ contains(inputs.build-command, 'mac-universal') && '-u' || '' }}-${{ inputs.scenario }}${{ inputs.type != '*' && format('-{0}',inputs.type) || '' }}
          output: e2e-logs-${{ inputs.os }}${{ contains(inputs.build-command, 'mac-universal') && '-u' || '' }}-${{ inputs.scenario }}${{ inputs.type != '*' && format('-{0}',inputs.type) || '' }}.zip
          paths: e2e/logs

      # Clean up temp directories after tests complete
      - name: üßπ Clean Up Temporary Directories
        shell: bash
        if: always()
        run: cd e2e && pnpm run clean:temp-dirs

      # Provide an interactive debugging session on failure
      - name: üêõ Debug Build on Failure
        uses: stateful/vscode-server-action@v1.1.0
        if: failure()
        with:
          timeout: '180000'
