name: E2E Tests
description: 'Runs end-to-end tests across different scenarios and JavaScript module types'

on:
  workflow_call:
    # Make this a reusable workflow, no value needed
    # https://docs.github.com/en/actions/using-workflows/reusing-workflows
    inputs:
      os:
        description: 'Operating system to run tests on'
        required: true
        type: string
      node-version:
        description: 'Node.js version to use for testing'
        required: true
        type: string
      build-command:
        description: 'Build command for test applications (build or build:mac-universal)'
        type: string
        default: 'build'
      scenario:
        description: 'Test scenario (forge, builder, or no-binary)'
        required: true
        type: string
      type:
        description: 'JavaScript module type (esm, cjs, or * for both)'
        type: string
        default: '*'
      build_id:
        description: 'Build ID from the build job'
        type: string
        required: false
      artifact_size:
        description: 'Size of the build artifact in bytes'
        type: string
        required: false
      cache_key:
        description: 'Cache key to use for downloading artifacts'
        type: string
        required: false

env:
  TURBO_TELEMETRY_DISABLED: 1

jobs:
  # This job runs E2E tests for a specific combination of:
  # - Operating system (Linux, Windows, macOS)
  # - Test scenario (builder, forge, no-binary)
  # - Module type (ESM, CJS, or both)
  e2e:
    name: E2E Tests
    runs-on: ${{ inputs.os }}
    timeout-minutes: 60
    strategy:
      # Continue with other tests even if one fails
      fail-fast: false
    steps:
      # Standard checkout with SSH key for private repositories
      - name: üë∑ Checkout Repository
        uses: actions/checkout@v4
        with:
          ssh-key: ${{ secrets.DEPLOY_KEY }}

      # Set up Node.js and PNPM using the reusable action
      - name: üõ†Ô∏è Setup Development Environment
        uses: ./.github/workflows/actions/setup-workspace
        with:
          node-version: ${{ inputs.node-version }}

      # Download the pre-built packages from the build job
      # This ensures all tests use the same build artifacts
      - name: üì¶ Download Build Artifacts
        uses: ./.github/workflows/actions/download-archive
        with:
          name: wdio-electron-service
          path: wdio-electron-service-build
          filename: artifact.zip
          cache_key_prefix: wdio-electron-build
          exact_cache_key: ${{ inputs.cache_key || github.run_id && format('{0}-{1}-{2}-{3}{4}', 'Linux', 'wdio-electron-build', 'wdio-electron-service', github.run_id, github.run_attempt > 1 && format('-rerun{0}', github.run_attempt) || '') || '' }}

      # Display build information if available
      - name: üìä Show Build Information
        if: inputs.build_id != '' && inputs.artifact_size != ''
        shell: bash
        run: |
          echo "::notice::Build artifact: ID=${{ inputs.build_id }}, Size=${{ inputs.artifact_size }} bytes"

      # Special workaround for Linux to enable Electron testing
      - name: üîß Apply Linux Kernel Workaround
        # https://github.com/electron/electron/issues/41066
        if: ${{ runner.os == 'Linux' }}
        shell: bash
        run: sudo sysctl -q -w kernel.apparmor_restrict_unprivileged_userns=0

      # Dynamically generate the Turbo filter for building test applications
      # This converts the scenario and type inputs into Turbo filter syntax
      - name: ü™Ñ Generate Build Filter for Test Apps
        id: gen-build
        uses: actions/github-script@v7
        with:
          result-encoding: string
          script: |
            const generateBuildFilter = (scenario, type) => {
              return scenario
                .split(',')
                .map((s) => `--filter=example-${s.trim()}-${type}`)
                .join(' ');
            };
            return generateBuildFilter('${{ inputs.scenario }}', '${{ inputs.type }}');

      # Show system information before building
      - name: üîç System Information Before Build
        shell: bash
        run: |
          echo "::group::System Information"
          echo "Runner OS: ${{ runner.os }}"
          echo "Runner Name: $RUNNER_NAME"
          echo "GitHub Job: $GITHUB_JOB"
          echo "Node.js version: $(node --version)"
          echo "PNPM version: $(pnpm --version)"
          echo "Current time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "Working directory: $(pwd)"
          echo "Available disk space:"
          df -h
          echo "Memory information:"
          if [[ "${{ runner.os }}" == "Linux" ]]; then
            free -h
          elif [[ "${{ runner.os }}" == "macOS" ]]; then
            vm_stat
          fi
          echo "Load average:"
          if [[ "${{ runner.os }}" != "Windows" ]]; then
            uptime
          fi
          echo "Running processes (top 10):"
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            tasklist | head -10 2>/dev/null || echo "Could not get process list"
          else
            ps aux 2>/dev/null | head -10 2>/dev/null || echo "Could not get process list"
          fi
          echo "::endgroup::"

      # Build the test applications using Turbo with the generated filter
      # This builds only the necessary test apps for the current test configuration
      - name: üèóÔ∏è Build Test Applications
        shell: bash
        run: |
          echo "::group::Build Command Info"
          echo "Build command: ${{ inputs.build-command }}"
          echo "Build filter: ${{ steps.gen-build.outputs.result }}"
          echo "Full command: pnpm exec turbo run ${{ inputs.build-command }} ${{ steps.gen-build.outputs.result }} --only --parallel"
          echo "Starting build at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "::endgroup::"

          # Run the actual build command
          pnpm exec turbo run ${{ inputs.build-command }} ${{ steps.gen-build.outputs.result }} --only --parallel

          echo "::group::Build Completion Info"
          echo "Build completed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "System state after build:"
          if [[ "${{ runner.os }}" != "Windows" ]]; then
            uptime
          fi
          echo "::endgroup::"

      # Dynamically generate the test commands to run
      # This handles both single and multiple scenarios, and ESM/CJS/both
      - name: ü™Ñ Generate Test Execution Plan
        id: gen-test
        uses: actions/github-script@v7
        with:
          result-encoding: string
          script: |
            const generateTestCommand = (scenario, type) => {
              return scenario
                .split(',')
                .flatMap((s) => {
                  const scenario = s.trim();
                  return type === '*'
                    ? [`test:e2e:${scenario}-esm`, `test:e2e:${scenario}-cjs`]
                    : [`test:e2e:${scenario}-${type}`];
                })
                .join(' ');
            };
            return generateTestCommand('${{ inputs.scenario }}', '${{ inputs.type }}');

      # Show system information before testing
      - name: üîç System Information Before Tests
        shell: bash
        run: |
          echo "::group::Pre-Test System State"
          echo "Current time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "Test commands to run: ${{ steps.gen-test.outputs.result }}"
          echo "System load and memory:"
          if [[ "${{ runner.os }}" == "Linux" ]]; then
            free -h
            echo "Load average: $(cat /proc/loadavg)"
          elif [[ "${{ runner.os }}" == "macOS" ]]; then
            vm_stat | head -5
            uptime
          fi
          echo "Electron processes (should be none):"
          if [[ "${{ runner.os }}" != "Windows" ]]; then
            pgrep -f [Ee]lectron || echo "No Electron processes found"
          fi
          echo "::endgroup::"

      # Run the E2E tests using Turbo with the generated test commands
      # First initializes the E2E environment, then runs the specific tests
      - name: üß™ Execute E2E Tests
        shell: bash
        run: |
          echo "::group::E2E Test Execution"
          echo "Starting E2E tests at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "Commands: pnpm exec turbo run init-e2es ${{ steps.gen-test.outputs.result }} --only"
          echo "::endgroup::"

          # Set up error handling
          set -e

          # Run the tests directly without timeout wrapping to avoid subprocess interference
          echo "Running E2E tests without timeout command to prevent subprocess issues"

          pnpm exec turbo run init-e2es ${{ steps.gen-test.outputs.result }} --only || {
            exit_code=$?
            echo "::error::E2E tests failed with exit code: $exit_code"
            echo "::group::Post-Failure System State"
            echo "Failure time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            if [[ "${{ runner.os }}" == "Linux" ]]; then
              uptime || true
              free -h || true
            elif [[ "${{ runner.os }}" == "macOS" ]]; then
              uptime || true
              vm_stat | head -5 || true
            fi
            echo "Remaining Electron processes:"
            if [[ "${{ runner.os }}" != "Windows" ]]; then
              pgrep -f [Ee]lectron || echo "No Electron processes found"
            fi
            echo "::endgroup::"
            exit $exit_code
          }

          echo "::group::E2E Test Completion"
          echo "E2E tests completed successfully at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          if [[ "${{ runner.os }}" != "Windows" ]]; then
            uptime
          fi
          echo "::endgroup::"

      # Show comprehensive debug information on failure
      - name: üêõ Debug Information on Failure
        shell: bash
        if: failure()
        run: |
          echo "::group::Failure Debug Information"
          echo "Failure occurred at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "GitHub Job: $GITHUB_JOB"
          echo "Runner OS: ${{ runner.os }}"
          echo "Scenario: ${{ inputs.scenario }}"
          echo "Type: ${{ inputs.type }}"
          echo "Build Command: ${{ inputs.build-command }}"

          echo "System state at failure:"
          if [[ "${{ runner.os }}" == "Linux" ]]; then
            free -h || true
            echo "Load average: $(cat /proc/loadavg 2>/dev/null || echo 'unavailable')"
            echo "Disk usage:" && df -h || true
          elif [[ "${{ runner.os }}" == "macOS" ]]; then
            vm_stat | head -5 || true
            uptime || true
            echo "Disk usage:" && df -h || true
          fi

          echo "Running processes:"
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            tasklist | head -15 2>/dev/null || echo "Could not get process list"
          else
            ps aux 2>/dev/null | head -15 2>/dev/null || echo "Could not get process list"
          fi

          echo "Electron processes:"
          if [[ "${{ runner.os }}" != "Windows" ]]; then
            pgrep -f [Ee]lectron || echo "No Electron processes found"
          fi

          echo "Network connections:"
          if [[ "${{ runner.os }}" == "Linux" ]]; then
            ss -tulpn | head -10 || true
          elif [[ "${{ runner.os }}" == "macOS" ]]; then
            netstat -an | head -10 || true
          fi
          echo "::endgroup::"

          echo "::group::Test Logs"
          pnpm run ci:e2e:logs || echo "Could not retrieve test logs"
          echo "::endgroup::"

      # Upload logs as artifacts on failure for later analysis
      # This helps debug issues without cluttering the GitHub Actions console
      - name: üì¶ Upload Test Logs on Failure
        uses: ./.github/workflows/actions/upload-archive
        if: failure()
        with:
          name: e2e-logs-${{ inputs.os }}${{ contains(inputs.build-command, 'mac-universal') && '-u' || '' }}-${{ inputs.scenario }}${{ inputs.type != '*' && format('-{0}',inputs.type) || '' }}
          output: e2e-logs-${{ inputs.os }}${{ contains(inputs.build-command, 'mac-universal') && '-u' || '' }}-${{ inputs.scenario }}${{ inputs.type != '*' && format('-{0}',inputs.type) || '' }}.zip
          paths: e2e/*/*.log

      # Provide an interactive debugging session on failure
      # This allows manual investigation of the environment
      - name: üêõ Debug Build on Failure
        uses: stateful/vscode-server-action@v1.1.0
        if: failure()
        with:
          timeout: '180000'
